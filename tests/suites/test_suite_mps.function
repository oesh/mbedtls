
/*
 * TODO: Test second argument in mbedtls_reader_reclaim!
 */

/* BEGIN_HEADER */

#include <stdlib.h>
#include "../include/mbedtls/mps/allocator.h"
#include "../include/mbedtls/mps/reader.h"
#include "../include/mbedtls/mps/writer.h"
#include "../include/mbedtls/mps/layer1.h"

/*
 * Compile-time configuration for test suite.
 */

/* Comment/Uncomment this to disable/enable the
 * testing of the various MPS layers.
 * This can be useful for time-consuming instrumentation
 * tasks such as the conversion of E-ACSL annotations
 * into runtime assertions. */
#define TEST_SUITE_MPS_READER
#define TEST_SUITE_MPS_WRITER
#define TEST_SUITE_MPS_L1

/* End of compile-time configuration. */

/*
 *
 * Helper structures for Layer 1 testing
 *
 * Layer 1 interfaces with the following components:
 * (1) An allocator providing the read and write buffers
 *     that the Layer 1 implementation uses when interfacing
 *     with the underlying transport (the interface for which
 *     does currently not allow in-place operations).
 * (2) The underlying stream or datagram transport (Layer 0).
 *
 */

/*
 * Mock object for a Layer 0 stream transport
 */

static size_t layer0_bufsize = 42;
typedef struct
{
    unsigned char *buf;
    size_t buflen;
    size_t avail;
} layer0_mock;

static layer0_mock c2s; /* Client-to-Server */
static layer0_mock s2c; /* Server-to-Client */

int layer0_init( layer0_mock *mbuf )
{
    mbuf->buf = malloc( layer0_bufsize );
    if( mbuf->buf == NULL )
        return( -1 );

    mbuf->avail = 0;
    mbuf->buflen = layer0_bufsize;
    return( 0 );
}

void layer0_free( layer0_mock *mbuf )
{
    if( mbuf->buf != NULL )
        free( mbuf->buf );
}

/* Read size bytes from mbuf into dst */
int layer0_read( layer0_mock* const mbuf, unsigned char *dst,
                 unsigned long size )
{
    size_t remaining;

    if( mbuf->avail == 0 )
        return( MPS_ERR_WANT_READ );

    if( size > mbuf->avail )
        size = mbuf->avail;

    /* Return only a part of the available buffer
     * to test how the upper layers deal with it. */
    size = ( size * ( ( rand() % 100 ) + 1 ) ) / 100;
    if( size == 0 )
        size = 1;
    remaining = mbuf->avail - size;

    memcpy( dst, mbuf->buf, size );
    memmove( mbuf->buf, mbuf->buf + size, remaining );

    mbuf->avail = remaining;
    return( size );
}

/* Write size bytes from src into mbuf */
int layer0_write( layer0_mock* const mbuf, const unsigned char *src,
                  size_t size )
{
    const size_t remaining = mbuf->buflen - mbuf->avail;

    if( size == 0 )
        return( 0 );

    if( remaining == 0 )
        return( MPS_ERR_WANT_WRITE );

    if( size > remaining )
        size = remaining;

    /* Return only a part of the available buffer
     * to test how the upper layers deal with it. */
    size = ( size * ( ( rand() % 100 ) + 1 ) ) / 100;
    if( size == 0 )
        size = 1;

    memcpy( mbuf->buf + mbuf->avail, src, size );
    mbuf->avail += size;

    return( size );
}

/* Write size bytes from src into the server to client buffer */
int layer0_write_srv( const unsigned char *src, size_t size )
{
    return layer0_write( &s2c, src, size );
}

/* Write size bytes from src into the client to server buffer */
int layer0_write_cli( const unsigned char *src, size_t size )
{
    return layer0_write( &c2s, src, size );
}

/* Read size bytes from the client to server buffer into dst */
int layer0_read_srv( unsigned char *dst, unsigned long size )
{
    return layer0_read( &c2s, dst, size );
}

/* Read size bytes from the server to client buffer into dst */
int layer0_read_cli( unsigned char *dst, unsigned long size )
{
    return layer0_read( &s2c, dst, size );
}

/*
 * Mock a Layer 0 datagram transport
 */

typedef struct
{
    unsigned char *buf;
    size_t buflen;
} layer0_dgram_mock_msg;

#define L0_MOCK_DGRAM_MAX_MSGS 128

/* Simply a FIFO of instances of layer0_dgram_mock_msg */
typedef struct
{
    layer0_dgram_mock_msg msgs[ L0_MOCK_DGRAM_MAX_MSGS ];
    size_t read_pos;
    size_t write_pos;
} layer0_dgram_mock;

static layer0_dgram_mock c2s_d; /* Client-to-Server */
static layer0_dgram_mock s2c_d; /* Server-to-Client */

static void layer0_dgram_msg_free( layer0_dgram_mock_msg *msg )
{
    free( msg->buf );
    msg->buf = NULL;
    msg->buflen = 0;
}

static int layer0_dgram_msg_init( layer0_dgram_mock_msg *msg, size_t len )
{
    msg->buf = malloc( len );
    if( msg->buf == NULL )
    {
        printf( "ALLOC FAILED\n" );
        return( -1 );
    }

    msg->buflen = len;
    return( 0 );
}

static int layer0_dgram_init( layer0_dgram_mock *ctx )
{
    layer0_dgram_mock_msg null_buf = { NULL, 0 };
    size_t idx;
    ctx->read_pos = 0;
    ctx->write_pos = 0;
    for( idx = 0; idx < L0_MOCK_DGRAM_MAX_MSGS; idx++ )
        ctx->msgs[idx] = null_buf;

    return( 0 );
}

static int layer0_dgram_free( layer0_dgram_mock *ctx )
{
    layer0_dgram_mock_msg null_buf = { NULL, 0 };
    size_t idx;
    ctx->read_pos = 0;
    ctx->write_pos = 0;
    for( idx = 0; idx < L0_MOCK_DGRAM_MAX_MSGS; idx++ )
        ctx->msgs[idx] = null_buf;

    return( 0 );
}

static size_t layer0_dgram_inc_idx( size_t idx )
{
    if( idx == L0_MOCK_DGRAM_MAX_MSGS - 1 )
        return( 0 );
    else
        return( idx + 1);
}

static int layer0_dgram_write( layer0_dgram_mock *ctx,
                               const unsigned char *src, size_t size )
{
    size_t write_pos = ctx->write_pos;
    size_t read_pos = ctx->read_pos;
    size_t new_write_pos = layer0_dgram_inc_idx( write_pos );
    if( new_write_pos == read_pos )
        return( MPS_ERR_WANT_WRITE );

    layer0_dgram_msg_init( &ctx->msgs[write_pos], size );
    memcpy( ctx->msgs[write_pos].buf, src, size );

    ctx->write_pos = new_write_pos;
    return( 0 );
}

static int layer0_dgram_read( layer0_dgram_mock *ctx,
                              unsigned char *dst, unsigned long size )
{
    size_t write_pos = ctx->write_pos;
    size_t read_pos = ctx->read_pos;
    size_t new_read_pos = layer0_dgram_inc_idx( read_pos );

    if( read_pos == write_pos )
        return( MPS_ERR_WANT_READ );

    if( ctx->msgs[read_pos].buflen > size )
        size = ctx->msgs[read_pos].buflen;

    memcpy( dst, ctx->msgs[read_pos].buf, size );
    layer0_dgram_msg_free( &ctx->msgs[read_pos] );

    ctx->read_pos = new_read_pos;
    return( (int) size );
}

/* Write size bytes from src into the server to client buffer */
int layer0_dgram_write_srv( const unsigned char *src, size_t size )
{
    return layer0_dgram_write( &s2c_d, src, size );
}

/* Write size bytes from src into the client to server buffer */
int layer0_dgram_write_cli( const unsigned char *src, size_t size )
{
    return layer0_dgram_write( &c2s_d, src, size );
}

/* Read size bytes from the client to server buffer into dst */
int layer0_dgram_read_srv( unsigned char *dst, unsigned long size )
{
    return layer0_dgram_read( &c2s_d, dst, size );
}

/* Read size bytes from the server to client buffer into dst */
int layer0_dgram_read_cli( unsigned char *dst, unsigned long size )
{
    return layer0_dgram_read( &s2c_d, dst, size );
}

/* END_HEADER */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_feed_empty( int option )
{
    unsigned char buf[100];
    unsigned char *tmp;
    mbedtls_reader rd;
    for( int i=0; (unsigned) i < sizeof( buf ); i++ )
        buf[i] = (unsigned char) i;

    /* Preparation (lower layer) */
    mbedtls_reader_init( &rd, NULL, 0 );
    switch( option )
    {
        case 0: /* NULL buffer */
            TEST_ASSERT( mbedtls_reader_feed( &rd, NULL, sizeof( buf ) ) ==
                         MBEDTLS_ERR_READER_INVALID_ARG );
            break;

        default:
            TEST_ASSERT( 0 );
            break;
    }
    /* Subsequent feed-calls should still succeed. */
    TEST_ASSERT( mbedtls_reader_feed( &rd, buf, sizeof( buf ) ) == 0 );

    /* Consumption (upper layer) */
    TEST_ASSERT( mbedtls_reader_get( &rd, 100, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, buf, 100 ) == 0 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );

    /* Wrapup */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    mbedtls_reader_free( &rd );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_no_pausing_single_step_single_round( int with_acc )
{
    /* The most basic use case: lower layer provides a buffer,
      * upper layer fetches it in a single go. */
    unsigned char bufA[100];
    unsigned char acc[10];
    unsigned char *tmp;
    mbedtls_reader rd;
    for( int i=0; (unsigned) i < sizeof( bufA ); i++ )
        bufA[i] = (unsigned char) i;

    /* Preparation (lower layer) */
    if( with_acc == 0 )
        mbedtls_reader_init( &rd, NULL, 0 );
    else
        mbedtls_reader_init( &rd, acc, sizeof( acc ) );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufA, sizeof( bufA ) ) == 0 );
    /* Consumption (upper layer) */
    /* Consume exactly what's available */
    TEST_ASSERT( mbedtls_reader_get( &rd, 100, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, bufA, 100 ) == 0 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    /* Wrapup (lower layer) */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    mbedtls_reader_free( &rd );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_no_pausing_single_step_multiple_rounds( int with_acc )
{
    /* Test multiple rounds of the lower layer providing data
     * and the upper layer fetching it in a single go. */
    unsigned char bufA[100], bufB[100];
    unsigned char acc[10];
    unsigned char *tmp;
    mbedtls_reader rd;
    for( int i=0; (unsigned) i < sizeof( bufA ); i++ )
        bufA[i] = (unsigned char) i;
    for( int i=0; (unsigned) i < sizeof( bufB ); i++ )
        bufB[i] = ~ ((unsigned char) i);

    /* Preparation (lower layer) */
    if( with_acc == 0 )
        mbedtls_reader_init( &rd, NULL, 0 );
    else
        mbedtls_reader_init( &rd, acc, sizeof( acc ) );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufA, sizeof( bufA ) ) == 0 );
    /* Consumption (upper layer) */
    /* Consume exactly what's available */
    TEST_ASSERT( mbedtls_reader_get( &rd, 100, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, bufA, 100 ) == 0 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    /* Preparation */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufB, sizeof( bufB ) ) == 0 );
    /* Consumption */
    TEST_ASSERT( mbedtls_reader_get( &rd, 100, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, bufB, 100 ) == 0 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    /* Wrapup (lower layer) */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    mbedtls_reader_free( &rd );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_no_pausing_multiple_steps_single_round( int with_acc )
{
    /* Lower layer provides data that the upper layer fully consumes
     * through multiple `get` calls. */
    unsigned char buf[100];
    unsigned char acc[10];
    unsigned char *tmp;
    size_t tmp_len;
    mbedtls_reader rd;
    for( int i=0; (unsigned) i < sizeof( buf ); i++ )
        buf[i] = (unsigned char) i;

    /* Preparation (lower layer) */
    if( with_acc == 0 )
        mbedtls_reader_init( &rd, NULL, 0 );
    else
        mbedtls_reader_init( &rd, acc, sizeof( acc ) );
    TEST_ASSERT( mbedtls_reader_feed( &rd, buf, sizeof( buf ) ) == 0 );
    /* Consumption (upper layer) */
    TEST_ASSERT( mbedtls_reader_get( &rd, 10, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, buf, 10 ) == 0 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 70, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, buf + 10, 70 ) == 0 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 30, &tmp, &tmp_len ) == 0 );
    TEST_ASSERT( tmp_len == 20 );
    TEST_ASSERT( memcmp( tmp, buf + 80, 20 ) == 0 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    /* Wrapup (lower layer) */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    mbedtls_reader_free( &rd );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_no_pausing_multiple_steps_multiple_rounds( int with_acc )
{
    /* Repeat "Lower layer provides data the the upper layer fully
     * consumes through multiple `get` calls" multiple times. */
    unsigned char bufA[100], bufB[100];
    unsigned char acc[10];
    unsigned char *tmp;
    size_t tmp_len;
    mbedtls_reader rd;
    for( int i=0; (unsigned) i < sizeof( bufA ); i++ )
        bufA[i] = (unsigned char) i;
    for( int i=0; (unsigned) i < sizeof( bufB ); i++ )
        bufB[i] = ~ ((unsigned char) i);

    /* Preparation (lower layer) */
    if( with_acc == 0 )
        mbedtls_reader_init( &rd, NULL, 0 );
    else
        mbedtls_reader_init( &rd, acc, sizeof( acc ) );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufA, sizeof( bufA ) ) == 0 );
    /* Consumption (upper layer) */
    TEST_ASSERT( mbedtls_reader_get( &rd, 10, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, bufA, 10 ) == 0 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 70, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, bufA + 10, 70 ) == 0 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 30, &tmp, &tmp_len ) == 0 );
    TEST_ASSERT( tmp_len == 20 );
    TEST_ASSERT( memcmp( tmp, bufA + 80, 20 ) == 0 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    /* Preparation */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufB, sizeof( bufB ) ) == 0 );
    /* Consumption */
    TEST_ASSERT( mbedtls_reader_get( &rd, 100, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, bufB, 100 ) == 0 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    /* Wrapup */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    mbedtls_reader_free( &rd );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_pausing_needed_disabled()
{
    /* If read-request goes beyond current read buffer
     * and pausing is not used, expected OUT_OF_DATA. */
    unsigned char buf[100];
    unsigned char *tmp;
    mbedtls_reader rd;
    for( int i=0; (unsigned) i < sizeof( buf ); i++ )
        buf[i] = (unsigned char) i;

    /* Preparation (lower layer) */
    mbedtls_reader_init( &rd, NULL, 0 );
    TEST_ASSERT( mbedtls_reader_feed( &rd, buf, sizeof( buf ) ) == 0 );
    /* Consumption (upper layer) */
    TEST_ASSERT( mbedtls_reader_get( &rd, 50, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, buf, 50 ) == 0 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 100, &tmp, NULL ) ==
                 MBEDTLS_ERR_READER_OUT_OF_DATA );
    /* Wrapup (lower layer) */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) ==
                 MBEDTLS_ERR_READER_NEED_ACCUMULATOR );
    mbedtls_reader_free( &rd );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_pausing_needed_buffer_too_small()
{
    /* If read-request goes beyond current read buffer
     * and pausing is used but the pause buffer is too small,
     * expect failure in the subsequent reclaim. */
    unsigned char buf[100];
    unsigned char acc[10];
    unsigned char *tmp;
    mbedtls_reader rd;
    for( int i=0; (unsigned) i < sizeof( buf ); i++ )
        buf[i] = (unsigned char) i;

    /* Preparation (lower layer) */
    mbedtls_reader_init( &rd, acc, sizeof( acc ) );
    TEST_ASSERT( mbedtls_reader_feed( &rd, buf, sizeof( buf ) ) == 0 );
    /* Consumption (upper layer) */
    TEST_ASSERT( mbedtls_reader_get( &rd, 50, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, buf, 50 ) == 0 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 100, &tmp, NULL ) ==
                 MBEDTLS_ERR_READER_OUT_OF_DATA );
    /* Wrapup (lower layer) */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) ==
                 MBEDTLS_ERR_READER_ACCUMULATOR_TOO_SMALL );
    mbedtls_reader_free( &rd );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_multiple_pausing( int option )
{
    unsigned char bufA[100], bufB[20], bufC[10];
    unsigned char *tmp;
    unsigned char acc[50];
    size_t tmp_len;
    mbedtls_reader rd;
    for( int i=0; (unsigned) i < sizeof( bufA ); i++ )
        bufA[i] = (unsigned char) i;
    for( int i=0; (unsigned) i < sizeof( bufB ); i++ )
        bufB[i] = ~ ((unsigned char) i);
    for( int i=0; (unsigned) i < sizeof( bufC ); i++ )
        bufC[i] = ~ ((unsigned char) i);

    /* Preparation (lower layer) */
    mbedtls_reader_init( &rd, acc, sizeof( acc ) );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufA, sizeof( bufA ) ) == 0 );

    /* Consumption (upper layer) */
    /* Ask for more than what's available. */
    TEST_ASSERT( mbedtls_reader_get( &rd, 80, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, bufA, 80 ) == 0 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 10, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, bufA + 80, 10 ) == 0 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 20, &tmp, NULL ) ==
                 MBEDTLS_ERR_READER_OUT_OF_DATA );

    /* Preparation */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufB, sizeof( bufB ) ) == 0 );

    switch( option )
    {
        case 0: /* Fetch same chunks, commit afterwards, and
                 * then exceed bounds of new buffer; accumulator
                 * large enough. */

            /* Consume */
            TEST_ASSERT( mbedtls_reader_get( &rd, 10, &tmp, &tmp_len ) == 0 );
            TEST_ASSERT( tmp_len == 10 );
            TEST_ASSERT( memcmp( tmp, bufA + 80, 10 ) == 0 );
            TEST_ASSERT( mbedtls_reader_get( &rd, 20, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 90, 10 ) == 0 );
            TEST_ASSERT( memcmp( tmp + 10, bufB, 10 ) == 0 );
            TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
            TEST_ASSERT( mbedtls_reader_get( &rd, 20, &tmp, NULL ) ==
                         MBEDTLS_ERR_READER_OUT_OF_DATA );

            /* Prepare */
            TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
            TEST_ASSERT( mbedtls_reader_feed( &rd, bufC, sizeof( bufC ) ) == 0 );;

            /* Consume */
            TEST_ASSERT( mbedtls_reader_get( &rd, 20, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufB + 10, 10 ) == 0 );
            TEST_ASSERT( memcmp( tmp + 10, bufC, 10 ) == 0 );
            break;

        case 1: /* Fetch same chunks, commit afterwards, and
                 * then exceed bounds of new buffer; accumulator
                 * not large enough. */
            TEST_ASSERT( mbedtls_reader_get( &rd, 10, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 80, 10 ) == 0 );
            TEST_ASSERT( mbedtls_reader_get( &rd, 20, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 90, 10 ) == 0 );
            TEST_ASSERT( memcmp( tmp + 10, bufB, 10 ) == 0 );
            TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
            TEST_ASSERT( mbedtls_reader_get( &rd, 51, &tmp, NULL ) ==
                         MBEDTLS_ERR_READER_OUT_OF_DATA );

            /* Prepare */
            TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) ==
                         MBEDTLS_ERR_READER_ACCUMULATOR_TOO_SMALL );
            break;

        case 2: /* Fetch same chunks, don't commit afterwards, and
                 * then exceed bounds of new buffer; accumulator
                 * large enough. */
            TEST_ASSERT( mbedtls_reader_get( &rd, 10, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 80, 10 ) == 0 );
            TEST_ASSERT( mbedtls_reader_get( &rd, 20, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 90, 10 ) == 0 );
            TEST_ASSERT( memcmp( tmp + 10, bufB, 10 ) == 0 );
            TEST_ASSERT( mbedtls_reader_get( &rd, 20, &tmp, NULL ) ==
                         MBEDTLS_ERR_READER_OUT_OF_DATA );

            /* Prepare */
            TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
            TEST_ASSERT( mbedtls_reader_feed( &rd, bufC, sizeof( bufC ) ) == 0 );;

            /* Consume */
            TEST_ASSERT( mbedtls_reader_get( &rd, 50, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 80, 20 ) == 0 );
            TEST_ASSERT( memcmp( tmp + 20, bufB, 20 ) == 0 );
            TEST_ASSERT( memcmp( tmp + 40, bufC, 10 ) == 0 );
            break;

        case 3: /* Fetch same chunks, don't commit afterwards, and
                 * then exceed bounds of new buffer; accumulator
                 * not large enough. */
            TEST_ASSERT( mbedtls_reader_get( &rd, 10, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 80, 10 ) == 0 );
            TEST_ASSERT( mbedtls_reader_get( &rd, 20, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 90, 10 ) == 0 );
            TEST_ASSERT( memcmp( tmp + 10, bufB, 10 ) == 0 );
            TEST_ASSERT( mbedtls_reader_get( &rd, 21, &tmp, NULL ) ==
                         MBEDTLS_ERR_READER_OUT_OF_DATA );

            /* Prepare */
            TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) ==
                         MBEDTLS_ERR_READER_ACCUMULATOR_TOO_SMALL );
            break;

        default:
            TEST_ASSERT( 0 );
            break;
    }

    mbedtls_reader_free( &rd );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_reclaim_data_left( int option )
{
    /* Attempt to reclaim when the higher layer
     * hasn't fully consumed the buffer. */
    unsigned char buf[100];
    unsigned char *tmp;
    mbedtls_reader rd;
    for( int i=0; (unsigned) i < sizeof( buf ); i++ )
        buf[i] = (unsigned char) i;

    /* Preparation (lower layer) */
    mbedtls_reader_init( &rd, NULL, 0 );
    TEST_ASSERT( mbedtls_reader_feed( &rd, buf, sizeof( buf ) ) == 0 );

    /* Consumption (upper layer) */
    switch( option )
    {
        case 0:
            /* Fetch (but not commit) the entire buffer. */
            TEST_ASSERT( mbedtls_reader_get( &rd, sizeof( buf ), &tmp, NULL )
                         == 0 );
            TEST_ASSERT( memcmp( tmp, buf, 100 ) == 0 );
            break;

        case 1:
            /* Fetch (but not commit) parts of the buffer. */
            TEST_ASSERT( mbedtls_reader_get( &rd, sizeof( buf ) / 2,
                                             &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, buf, sizeof( buf ) / 2 ) == 0 );
            break;

        case 2:
            /* Fetch and commit parts of the buffer, then
             * fetch but not commit the rest of the buffer. */
            TEST_ASSERT( mbedtls_reader_get( &rd, sizeof( buf ) / 2,
                                             &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, buf, sizeof( buf ) / 2 ) == 0 );
            TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
            TEST_ASSERT( mbedtls_reader_get( &rd, sizeof( buf ) / 2,
                                             &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, buf + sizeof( buf ) / 2,
                                 sizeof( buf ) / 2 ) == 0 );
            break;

        default:
            TEST_ASSERT( 0 );
            break;
    }

    /* Wrapup */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) ==
                 MBEDTLS_ERR_READER_DATA_LEFT );
    mbedtls_reader_free( &rd );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_reclaim_data_left_retry()
{
    /* Lower layer attempts to reclaim but finds that data
     * remains to be consumed and hence passes the reader
     * back to upper layer who continues processing. */
    unsigned char buf[100];
    unsigned char *tmp;
    mbedtls_reader rd;

    for( int i=0; (unsigned) i < sizeof( buf ); i++ )
        buf[i] = (unsigned char) i;

    /* Preparation (lower layer) */
    mbedtls_reader_init( &rd, NULL, 0 );
    TEST_ASSERT( mbedtls_reader_feed( &rd, buf, sizeof( buf ) ) == 0 );
    /* Consumption (upper layer) */
    TEST_ASSERT( mbedtls_reader_get( &rd, 50, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, buf, 50 ) == 0 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 50, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, buf + 50, 50 ) == 0 );
    /* Preparation */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) ==
                 MBEDTLS_ERR_READER_DATA_LEFT );
    /* Consumption */
    TEST_ASSERT( mbedtls_reader_get( &rd, 50, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, buf + 50, 50 ) == 0 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    /* Wrapup */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    mbedtls_reader_free( &rd );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_pausing( int option )
{
    unsigned char bufA[100], bufB[100];
    unsigned char *tmp;
    unsigned char acc[40];
    mbedtls_reader rd;
    for( int i=0; (unsigned) i < sizeof( bufA ); i++ )
        bufA[i] = (unsigned char) i;
    for( int i=0; (unsigned) i < sizeof( bufB ); i++ )
        bufB[i] = ~ ((unsigned char) i);

    /* Preparation (lower layer) */
    mbedtls_reader_init( &rd, acc, sizeof( acc ) );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufA, sizeof( bufA ) ) == 0 );

    /* Consumption (upper layer) */
    /* Ask for more than what's available. */
    TEST_ASSERT( mbedtls_reader_get( &rd, 80, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, bufA, 80 ) == 0 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 10, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, bufA + 80, 10 ) == 0 );
    switch( option )
    {
        case 0:  /* Single uncommited fetch at pausing */
        case 1:
            TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
            break;
        default: /* Multiple uncommitted fetches at pausing */
            break;
    }
    TEST_ASSERT( mbedtls_reader_get( &rd, 20, &tmp, NULL ) ==
                 MBEDTLS_ERR_READER_OUT_OF_DATA );

    /* Preparation */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufB, sizeof( bufB ) ) == 0 );

    /* Consumption */
    switch( option )
    {
        case 0: /* Single fetch at pausing, re-fetch with commit. */
            TEST_ASSERT( mbedtls_reader_get( &rd, 20, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 90, 10 ) == 0 );
            TEST_ASSERT( memcmp( tmp + 10, bufB, 10 ) == 0 );
            TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
            break;

        case 1: /* Single fetch at pausing, re-fetch without commit. */
            TEST_ASSERT( mbedtls_reader_get( &rd, 20, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 90, 10 ) == 0 );
            TEST_ASSERT( memcmp( tmp + 10, bufB, 10 ) == 0 );
            break;

        case 2: /* Multiple fetches at pausing, repeat without commit. */
            TEST_ASSERT( mbedtls_reader_get( &rd, 10, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 80, 10 ) == 0 );
            TEST_ASSERT( mbedtls_reader_get( &rd, 20, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 90, 10 ) == 0 );
            TEST_ASSERT( memcmp( tmp + 10, bufB, 10 ) == 0 );
            break;

        case 3: /* Multiple fetches at pausing, repeat with commit 1. */
            TEST_ASSERT( mbedtls_reader_get( &rd, 10, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 80, 10 ) == 0 );
            TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
            TEST_ASSERT( mbedtls_reader_get( &rd, 20, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 90, 10 ) == 0 );
            TEST_ASSERT( memcmp( tmp + 10, bufB, 10 ) == 0 );
            break;

        case 4: /* Multiple fetches at pausing, repeat with commit 2. */
            TEST_ASSERT( mbedtls_reader_get( &rd, 10, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 80, 10 ) == 0 );
            TEST_ASSERT( mbedtls_reader_get( &rd, 20, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 90, 10 ) == 0 );
            TEST_ASSERT( memcmp( tmp + 10, bufB, 10 ) == 0 );
            TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
            break;

        case 5: /* Multiple fetches at pausing, repeat with commit 3. */
            TEST_ASSERT( mbedtls_reader_get( &rd, 10, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 80, 10 ) == 0 );
            TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
            TEST_ASSERT( mbedtls_reader_get( &rd, 20, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 90, 10 ) == 0 );
            TEST_ASSERT( memcmp( tmp + 10, bufB, 10 ) == 0 );
            TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
            break;

        default:
            TEST_ASSERT( 0 );
    }

    /* In all cases, fetch the rest of the second buffer. */
    TEST_ASSERT( mbedtls_reader_get( &rd, 90, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, bufB + 10, 90 ) == 0 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );

    /* Wrapup */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    mbedtls_reader_free( &rd );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_pausing_multiple_feeds( int option )
{
    unsigned char bufA[100], bufB[100];
    unsigned char *tmp;
    unsigned char acc[70];
    mbedtls_reader rd;
    size_t fetch_len;
    for( int i=0; (unsigned) i < sizeof( bufA ); i++ )
        bufA[i] = (unsigned char) i;
    for( int i=0; (unsigned) i < sizeof( bufB ); i++ )
        bufB[i] = ~ ((unsigned char) i);

    /* Preparation (lower layer) */
    mbedtls_reader_init( &rd, acc, sizeof( acc ) );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufA, sizeof( bufA ) ) == 0 );

    /* Consumption (upper layer) */
    /* Ask for more than what's available. */
    TEST_ASSERT( mbedtls_reader_get( &rd, 80, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, bufA, 80 ) == 0 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    /* 20 left, ask for 70 -> 50 overhead */
    TEST_ASSERT( mbedtls_reader_get( &rd, 70, &tmp, NULL ) ==
                 MBEDTLS_ERR_READER_OUT_OF_DATA );

    /* Preparation */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    switch( option )
    {
        case 0: /* 10 + 10 + 80 byte feed */
            TEST_ASSERT( mbedtls_reader_feed( &rd, bufB, 10 ) ==
                         MBEDTLS_ERR_READER_NEED_MORE );
            TEST_ASSERT( mbedtls_reader_feed( &rd, bufB + 10, 10 ) ==
                         MBEDTLS_ERR_READER_NEED_MORE );
            TEST_ASSERT( mbedtls_reader_feed( &rd, bufB + 20, 80 ) == 0 );
            break;

        case 1: /* 50 x 1byte */
            for( int num_feed=0; num_feed<49; num_feed++ )
            {
                TEST_ASSERT( mbedtls_reader_feed( &rd, bufB + num_feed, 1 ) ==
                             MBEDTLS_ERR_READER_NEED_MORE );
            }
            TEST_ASSERT( mbedtls_reader_feed( &rd, bufB + 49, 1 ) == 0 );
            break;

        case 2: /* 49 x 1byte + 51bytes */
            for( int num_feed=0; num_feed<49; num_feed++ )
            {
                TEST_ASSERT( mbedtls_reader_feed( &rd, bufB + num_feed, 1 ) ==
                             MBEDTLS_ERR_READER_NEED_MORE );
            }
            TEST_ASSERT( mbedtls_reader_feed( &rd, bufB + 49, 51 ) == 0 );
            break;

        default:
            TEST_ASSERT( 0 );
            break;
    }

    /* Consumption */
    TEST_ASSERT( mbedtls_reader_get( &rd, 70, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, bufA + 80, 20 ) == 0 );
    TEST_ASSERT( memcmp( tmp + 20, bufB, 50 ) == 0 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 1000, &tmp, &fetch_len ) == 0 );
    switch( option )
    {
        case 0:
            TEST_ASSERT( fetch_len == 50 );
            break;

        case 1:
            TEST_ASSERT( fetch_len == 0 );
            break;

        case 2:
            TEST_ASSERT( fetch_len == 50 );
            break;

        default:
            TEST_ASSERT( 0 );
            break;
    }
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );

    /* Wrapup */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    mbedtls_reader_free( &rd );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_commit_in_old()
{
    unsigned char bufA[100], bufB[100];
    unsigned char *tmp;
    unsigned char acc[40];
    mbedtls_reader rd;
    for( int i=0; (unsigned) i < sizeof( bufA ); i++ )
        bufA[i] = (unsigned char) i;
    for( int i=0; (unsigned) i < sizeof( bufB ); i++ )
        bufB[i] = ~ ((unsigned char) i);

    /* Preparation (lower layer) */
    mbedtls_reader_init( &rd, acc, sizeof( acc ) );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufA, sizeof( bufA ) ) == 0 );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufA, sizeof( bufA ) ) ==
                 MBEDTLS_ERR_READER_UNEXPECTED_OPERATION );
    /* Consumption (upper layer) */
    /* Ask for more than what's available. */
    TEST_ASSERT( mbedtls_reader_get( &rd, 80, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, bufA, 80 ) == 0 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 10, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, bufA + 80, 10 ) == 0 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 20, &tmp, NULL ) ==
                 MBEDTLS_ERR_READER_OUT_OF_DATA );
    TEST_ASSERT( mbedtls_reader_get( &rd, 10, &tmp, NULL ) ==
                 MBEDTLS_ERR_READER_UNEXPECTED_OPERATION );
    /* Preparation */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufB, 5 ) ==
                 MBEDTLS_ERR_READER_NEED_MORE );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufB + 5, 3 ) ==
                 MBEDTLS_ERR_READER_NEED_MORE );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufB + 8, sizeof( bufB ) - 8 ) ==
                 0 );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufB, sizeof( bufB ) ) ==
                 MBEDTLS_ERR_READER_UNEXPECTED_OPERATION );
    /* Consumption */
    TEST_ASSERT( mbedtls_reader_get( &rd, 10, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, bufA + 80, 10 ) == 0 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 20, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, bufA + 90, 10 ) == 0 );
    TEST_ASSERT( memcmp( tmp + 10, bufB, 10 ) == 0 );
    /* Wrapup */
    mbedtls_reader_free( &rd );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_reader_inconsistent_usage( int option )
{
    unsigned char bufA[100], bufB[100];
    unsigned char *tmp;
    unsigned char acc[40];
    mbedtls_reader rd;
    int success = 0;
    for( int i=0; (unsigned) i < sizeof( bufA ); i++ )
        bufA[i] = (unsigned char) i;
    for( int i=0; (unsigned) i < sizeof( bufB ); i++ )
        bufB[i] = ~ ((unsigned char) i);

    /* Preparation (lower layer) */
    mbedtls_reader_init( &rd, acc, sizeof( acc ) );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufA, sizeof( bufA ) ) == 0 );
    /* Consumption (upper layer) */
    TEST_ASSERT( mbedtls_reader_get( &rd, 80, &tmp, NULL ) == 0 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 10, &tmp, NULL ) == 0 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 20, &tmp, NULL ) ==
                 MBEDTLS_ERR_READER_OUT_OF_DATA );
    /* Preparation */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufB, sizeof( bufB ) ) == 0 );
    /* Consumption */
    switch( option )
    {
        case 0:
            /* Ask for buffered data in a single chunk, no commit */
            TEST_ASSERT( mbedtls_reader_get( &rd, 30, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 80, 20 ) == 0 );
            TEST_ASSERT( memcmp( tmp + 20, bufB, 10 ) == 0 );
            success = 1;
            break;

        case 1:
            /* Ask for buffered data in a single chunk, with commit */
            TEST_ASSERT( mbedtls_reader_get( &rd, 30, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 80, 20 ) == 0 );
            TEST_ASSERT( memcmp( tmp + 20, bufB, 10 ) == 0 );
            TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
            success = 1;
            break;

        case 2:
            /* Ask for more than was requested when pausing, #1 */
            TEST_ASSERT( mbedtls_reader_get( &rd, 31, &tmp, NULL ) ==
                         MBEDTLS_ERR_READER_INCONSISTENT_REQUESTS );
            break;

        case 3:
            /* Ask for more than was requested when pausing #2 */
            TEST_ASSERT( mbedtls_reader_get( &rd, (unsigned) -1, &tmp, NULL ) ==
                         MBEDTLS_ERR_READER_INCONSISTENT_REQUESTS );
            break;

        case 4:
            /* Asking for buffered data in different
             * chunks than before CAN fail. */
            TEST_ASSERT( mbedtls_reader_get( &rd, 15, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 80, 15 ) == 0 );
            TEST_ASSERT( mbedtls_reader_get( &rd, 10, &tmp, NULL ) ==
                         MBEDTLS_ERR_READER_INCONSISTENT_REQUESTS );
            break;

        case 5:
            /* Asking for buffered data different chunks
             * than before NEED NOT fail - no commits */
            TEST_ASSERT( mbedtls_reader_get( &rd, 15, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 80, 15 ) == 0 );
            TEST_ASSERT( mbedtls_reader_get( &rd, 15, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 95, 5 ) == 0 );
            TEST_ASSERT( memcmp( tmp + 5, bufB, 10 ) == 0 );
            success = 1;
            break;

        case 6:
            /* Asking for buffered data different chunks
             * than before NEED NOT fail - intermediate commit */
            TEST_ASSERT( mbedtls_reader_get( &rd, 15, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 80, 15 ) == 0 );
            TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
            TEST_ASSERT( mbedtls_reader_get( &rd, 15, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 95, 5 ) == 0 );
            TEST_ASSERT( memcmp( tmp + 5, bufB, 10 ) == 0 );
            success = 1;
            break;

        case 7:
            /* Asking for buffered data different chunks
             * than before NEED NOT fail - end commit */
            TEST_ASSERT( mbedtls_reader_get( &rd, 15, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 80, 15 ) == 0 );
            TEST_ASSERT( mbedtls_reader_get( &rd, 15, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 95, 5 ) == 0 );
            TEST_ASSERT( memcmp( tmp + 5, bufB, 10 ) == 0 );
            TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
            success = 1;
            break;

        case 8:
            /* Asking for buffered data different chunks
             * than before NEED NOT fail - intermediate & end commit */
            TEST_ASSERT( mbedtls_reader_get( &rd, 15, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 80, 15 ) == 0 );
            TEST_ASSERT( mbedtls_reader_get( &rd, 15, &tmp, NULL ) == 0 );
            TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 95, 5 ) == 0 );
            TEST_ASSERT( memcmp( tmp + 5, bufB, 10 ) == 0 );
            TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
            success = 1;
            break;

        default:
            TEST_ASSERT( 0 );
            break;
    }

    if( success == 1 )
    {
        /* In all succeeding cases, fetch the rest of the second buffer. */
        TEST_ASSERT( mbedtls_reader_get( &rd, 90, &tmp, NULL ) == 0 );
        TEST_ASSERT( memcmp( tmp, bufB + 10, 90 ) == 0 );
        TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );

        /* Wrapup */
        TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    }

    /* Wrapup */
    mbedtls_reader_free( &rd );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_random_usage( int num_out_chunks,
                                      int max_chunk_size,
                                      int max_request,
                                      int acc_size )

{
    /* Randomly pass a reader object back and forth between lower and
     * upper layer and let each of them call the respective reader API
     * functions in a random fashion.
     *
     * On the lower layer, we're tracking and concatenating
     * the data passed to successful feed calls.
     *
     * For the upper layer, we track and concatenate buffers
     * obtained from successful get calls.
     *
     * As long as the lower layer calls reclaim at least once, (resetting the
     * fetched but not-yet-committed data), this should always lead to the same
     * stream of outgoing/incoming data for the lower/upper layers, even if
     * most of the random calls fail.
     *
     * NOTE: This test uses rand() for random data, which is not optimal.
     *       Instead, it would be better to get the random data from a
     *       static buffer. This both eases reproducibility and allows
     *       simple conversion to a fuzz target.
     */
    int ret;
    unsigned char *acc = NULL;
    unsigned char *outgoing, *incoming;
    unsigned char *cur_chunk = NULL;
    size_t cur_out_chunk, out_pos, in_commit, in_fetch;
    int rand_op;  /* Lower layer:
                   * - Reclaim (0)
                   * - Feed (1)
                   * Upper layer:
                   * - Get, do tolerate smaller output (0)
                   * - Get, don't tolerate smaller output (1)
                   * - Commit (2) */
    int mode = 0; /* Lower layer (0) or Upper layer (1) */
    int reclaimed = 1; /* Have to call reclaim at least once before
                        * returning the reader to the upper layer. */
    mbedtls_reader rd;

    if( acc_size > 0 )
    {
        acc = malloc( acc_size );
        TEST_ASSERT( acc != NULL );
    }

    /* This probably needs to be changed because we want
     * our tests to be deterministic. */
//    srand( time( NULL ) );

    outgoing = malloc( num_out_chunks * max_chunk_size );
    incoming = malloc( num_out_chunks * max_chunk_size );
    TEST_ASSERT( outgoing != NULL );
    TEST_ASSERT( incoming != NULL );

    mbedtls_reader_init( &rd, acc, acc_size );

    cur_out_chunk = 0;
    in_commit = 0;
    in_fetch = 0;
    out_pos = 0;
    while( cur_out_chunk < (unsigned) num_out_chunks )
    {
        if( mode == 0 )
        {
            /* Choose randomly between reclaim and feed */
            rand_op = rand() % 2;

            if( rand_op == 0 )
            {
                /* Reclaim */
                ret = mbedtls_reader_reclaim( &rd, NULL );

                if( ret == 0 )
                {
                    TEST_ASSERT( cur_chunk != NULL );
                    free( cur_chunk );
                    cur_chunk = NULL;
                }
                reclaimed = 1;
            }
            else
            {
                /* Feed reader with a random chunk */
                unsigned char *tmp;
                size_t tmp_size;
                if( cur_out_chunk == (unsigned) num_out_chunks )
                    continue;

                tmp_size = ( rand() % max_chunk_size ) + 1;
                tmp = malloc( tmp_size );
                TEST_ASSERT( tmp != NULL );

                TEST_ASSERT( rnd_std_rand( NULL, tmp, tmp_size ) == 0 );
                ret = mbedtls_reader_feed( &rd, tmp, tmp_size );

                if( ret == 0 || ret == MBEDTLS_ERR_READER_NEED_MORE )
                {
                    cur_out_chunk++;
                    memcpy( outgoing + out_pos, tmp, tmp_size );
                    out_pos += tmp_size;
                }

                if( ret == 0 )
                {
                    TEST_ASSERT( cur_chunk == NULL );
                    cur_chunk = tmp;
                }
                else
                {
                    free( tmp );
                }

            }

            /* Randomly switch to consumption mode if reclaim
             * was called at least once. */
            if( reclaimed == 1 && rand() % 3 == 0 )
            {
                in_fetch = 0;
                mode = 1;
            }
        }
        else
        {
            /* Choose randomly between get tolerating fewer data,
             * get not tolerating fewer data, and commit. */
            rand_op = rand() % 3;
            if( rand_op == 0 || rand_op == 1 )
            {
                size_t get_size, real_size;
                unsigned char *chunk_get;
                get_size = ( rand() % max_request ) + 1;
                if( rand_op == 0 )
                {
                    ret = mbedtls_reader_get( &rd, get_size, &chunk_get,
                                              &real_size );
                }
                else
                {
                    real_size = get_size;
                    ret = mbedtls_reader_get( &rd, get_size, &chunk_get, NULL );
                }

                /* Check if output is in accordance with what was written */
                if( ret == 0 )
                {
                    memcpy( incoming + in_commit + in_fetch,
                            chunk_get, real_size );
                    TEST_ASSERT( memcmp( incoming + in_commit + in_fetch,
                                         outgoing + in_commit + in_fetch,
                                         real_size ) == 0 );
                    in_fetch += real_size;
                }
            }
            else if( rand_op == 2 ) /* Commit */
            {
                ret = mbedtls_reader_commit( &rd );
                if( ret == 0 )
                {
                    in_commit += in_fetch;
                    in_fetch = 0;
                }
            }

            /* Randomly switch back to preparation */
            if( rand() % 3 == 0 )
            {
                reclaimed = 0;
                mode = 0;
            }
        }
    }

    /* Cleanup */
    mbedtls_reader_free( &rd );
    free( incoming );
    free( outgoing );
    free( acc );
    free( cur_chunk );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_ext_basic( )
{
    /* This test checks whether the extended reader correctly
     * checks for the global bounds of the logical buffer. */

    mbedtls_reader_ext rd_ext;
    mbedtls_reader rd;
    unsigned char buf[75];
    unsigned char *tmp;
    size_t tmp_sz;

    /* Initialize reader and extended reader separately. */
    TEST_ASSERT( mbedtls_reader_init_ext( &rd_ext, 100 ) == 0 );
    mbedtls_reader_init( &rd, NULL, 0 );
    for( size_t idx=0; idx < sizeof( buf ); idx++ )
        buf[idx] = (unsigned char) idx;

    /* Prepare reader and bind it to extended reader */
    TEST_ASSERT( mbedtls_reader_feed( &rd, buf, sizeof( buf ) ) == 0 );
    TEST_ASSERT( mbedtls_reader_attach( &rd_ext, &rd ) == 0 );

    /* Do actual fetching */
    TEST_ASSERT( mbedtls_reader_get_ext( &rd_ext, 101, &tmp, NULL ) ==
                 MBEDTLS_ERR_READER_BOUNDS_VIOLATION );

    /* ([C]ommit, [F]etch) = (0,0) */
    TEST_ASSERT( mbedtls_reader_get_ext( &rd_ext, 50, &tmp, NULL ) == 0 );
    /* Now (C,F) = (0,50) */
    TEST_ASSERT( mbedtls_reader_get_ext( &rd_ext, 10, &tmp, NULL ) == 0 );
    /* Now (C,F) = (0,60) */
    TEST_ASSERT( mbedtls_reader_commit_ext( &rd_ext ) == 0 );
    /* Now (C,F) = (60,60) */
    TEST_ASSERT( mbedtls_reader_get_ext( &rd_ext, 41, &tmp, NULL ) ==
                 MBEDTLS_ERR_READER_BOUNDS_VIOLATION );
    /* Now (C,F) = (60,60) */
    TEST_ASSERT( mbedtls_reader_get_ext( &rd_ext, 40,
                                         &tmp, &tmp_sz ) == 0 );
    TEST_ASSERT( tmp_sz == 15 );
    /* Now (C,F) = (60,75) */
    TEST_ASSERT( mbedtls_reader_get_ext( &rd_ext, 26, &tmp, &tmp_sz ) ==
                 MBEDTLS_ERR_READER_BOUNDS_VIOLATION );
    TEST_ASSERT( mbedtls_reader_get_ext( &rd_ext, 25, &tmp, NULL ) ==
                 MBEDTLS_ERR_READER_OUT_OF_DATA );
    TEST_ASSERT( mbedtls_reader_get_ext( &rd_ext, 25, &tmp, &tmp_sz ) == 0 );
    TEST_ASSERT( tmp_sz == 0 );
    /* Now still (C,F) = (60,75) */

    TEST_ASSERT( mbedtls_reader_detach( &rd_ext ) == 0 );

exit:

    mbedtls_reader_free_ext( &rd_ext );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_ext_group_open_close( )
{
    /* This test checks whether the extended reader correctly
     * checks for the global bounds of the logical buffer. */

    mbedtls_reader_ext rd_ext;
    mbedtls_reader rd;
    unsigned char buf[75];
    unsigned char *tmp;
    size_t tmp_sz;

    /* Initialize reader and extended reader separately. */
    TEST_ASSERT( mbedtls_reader_init_ext( &rd_ext, 100 ) == 0 );
    mbedtls_reader_init( &rd, NULL, 0 );
    for( size_t idx=0; idx < sizeof( buf ); idx++ )
        buf[idx] = (unsigned char) idx;

    /* Prepare reader and bind it to extended reader */
    TEST_ASSERT( mbedtls_reader_feed( &rd, buf, sizeof( buf ) ) == 0 );
    TEST_ASSERT( mbedtls_reader_attach( &rd_ext, &rd ) == 0 );

    /* Do actual fetching */
    TEST_ASSERT( mbedtls_reader_get_ext( &rd_ext, 101, &tmp, NULL ) ==
                 MBEDTLS_ERR_READER_BOUNDS_VIOLATION );

    /* ([C]ommit, [F]etch) = (0,0) */
    TEST_ASSERT( mbedtls_reader_get_ext( &rd_ext, 50, &tmp, NULL ) == 0 );
    /* Now (C,F) = (0,50) */
    TEST_ASSERT( mbedtls_reader_group_open( &rd_ext, 51 ) ==
                 MBEDTLS_ERR_READER_BOUNDS_VIOLATION );
    TEST_ASSERT( mbedtls_reader_group_open( &rd_ext, 20 ) == 0 );
    /* Now (C,F) have a sub-group in the range from 50-70 */
    TEST_ASSERT( mbedtls_reader_get_ext( &rd_ext, 21, &tmp, NULL ) ==
                 MBEDTLS_ERR_READER_BOUNDS_VIOLATION );
    TEST_ASSERT( mbedtls_reader_get_ext( &rd_ext, 10, &tmp, NULL ) == 0 );
    /* Now (C,F) = (0,60) */
    /* Cannot close group yet */
    TEST_ASSERT( mbedtls_reader_group_close( &rd_ext ) ==
                 MBEDTLS_ERR_READER_BOUNDS_VIOLATION );
    TEST_ASSERT( mbedtls_reader_get_ext( &rd_ext, 10, &tmp, NULL ) == 0 );
    /* Now (C,F) = (0,70) */
    TEST_ASSERT( mbedtls_reader_get_ext( &rd_ext, 1, &tmp, NULL ) ==
                 MBEDTLS_ERR_READER_BOUNDS_VIOLATION );
    TEST_ASSERT( mbedtls_reader_group_close( &rd_ext ) == 0 );
    /* Now only open group is 0-100 again */
    TEST_ASSERT( mbedtls_reader_commit_ext( &rd_ext ) == 0 );
    /* Now (C,F) = (70,70) */
    TEST_ASSERT( mbedtls_reader_get_ext( &rd_ext, 1, &tmp, NULL ) == 0 );
    /* Now (C,F) = (70,71) */
    TEST_ASSERT( mbedtls_reader_get_ext( &rd_ext, 30, &tmp, NULL ) ==
                 MBEDTLS_ERR_READER_BOUNDS_VIOLATION );
    TEST_ASSERT( mbedtls_reader_get_ext( &rd_ext, 29, &tmp, &tmp_sz ) == 0 );
    TEST_ASSERT( tmp_sz == 4 );
    /* Now (C,F) = (70, 75) */

    TEST_ASSERT( mbedtls_reader_detach( &rd_ext ) == 0 );

exit:

    mbedtls_reader_free_ext( &rd_ext );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_ext_many_groups( )
{
    /* This test checks whether the extended reader correctly
     * checks for the global bounds of the logical buffer. */

    mbedtls_reader_ext rd_ext;
    mbedtls_reader rd;
    unsigned char buf[75];
    unsigned char *tmp;

    /* Initialize reader and extended reader separately. */
    TEST_ASSERT( mbedtls_reader_init_ext( &rd_ext, 100 ) == 0 );
    mbedtls_reader_init( &rd, NULL, 0 );
    for( size_t idx=0; idx < sizeof( buf ); idx++ )
        buf[idx] = (unsigned char) idx;

    /* Prepare reader and bind it to extended reader */
    TEST_ASSERT( mbedtls_reader_feed( &rd, buf, sizeof( buf ) ) == 0 );
    TEST_ASSERT( mbedtls_reader_attach( &rd_ext, &rd ) == 0 );

    for( size_t cur_grp=1; cur_grp < MBEDTLS_READER_MAX_GROUPS; cur_grp++ )
    {
        TEST_ASSERT( mbedtls_reader_get_ext( &rd_ext, 100 - 2 * cur_grp + 3,
                                             &tmp, NULL ) ==
                     MBEDTLS_ERR_READER_BOUNDS_VIOLATION );
        TEST_ASSERT( mbedtls_reader_get_ext( &rd_ext, 1, &tmp, NULL ) == 0 );
        TEST_ASSERT( mbedtls_reader_group_open( &rd_ext,
                                                100 - 2 * ( cur_grp - 1 ) ) ==
                     MBEDTLS_ERR_READER_BOUNDS_VIOLATION );
        TEST_ASSERT( mbedtls_reader_group_open( &rd_ext,
                                                100 - 2 * cur_grp ) == 0 );
    }

    TEST_ASSERT( mbedtls_reader_group_open( &rd_ext, 1 ) ==
                 MBEDTLS_ERR_READER_TOO_MANY_GROUPS );

    TEST_ASSERT( mbedtls_reader_detach( &rd_ext ) == 0 );

exit:

    mbedtls_reader_free_ext( &rd_ext );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_WRITER */
void mbedtls_mps_writer_feed_empty( int option )
{
    unsigned char buf[100];
    unsigned char *tmp;
    mbedtls_writer wr;
    for( int i=0; (unsigned) i < sizeof( buf ); i++ )
        buf[i] = (unsigned char) i;

    /* Provisioning (lower layer) */
    mbedtls_writer_init( &wr, NULL, 0 );
    switch( option )
    {
        case 0: /* NULL buffer */
            TEST_ASSERT( mbedtls_writer_feed( &wr, NULL, 0 ) ==
                         MBEDTLS_ERR_WRITER_INVALID_ARG );
            break;

        default:
            TEST_ASSERT( 0 );
            break;
    }
    /* Subsequent feed-calls should still succeed. */
    TEST_ASSERT( mbedtls_writer_feed( &wr, buf, sizeof( buf ) ) == 0 );
    /* Producing (upper layer) */
    TEST_ASSERT( mbedtls_writer_get( &wr, 100, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, buf, 100 ) == 0 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    /* Wrapup */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) == 0 );
    mbedtls_writer_free( &wr );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_WRITER */
void mbedtls_mps_writer_no_queueing_single_step_single_round( int with_queue )
{
    /* The most basic use case: lower layer provides space
     * for outgoing data to be written to, and upper layer
     * fetches and writes it in a single go. */
    unsigned char buf[100];
    unsigned char out[100];
    unsigned char queue[10];
    unsigned char *tmp;
    mbedtls_writer wr;

    for( int i=0; (unsigned) i < 100; i++ )
        out[i] = (unsigned char) i;

    /* Provisioning (lower layer) */
    if( with_queue == 0 )
        mbedtls_writer_init( &wr, NULL, 0 );
    else
        mbedtls_writer_init( &wr, queue, sizeof( queue ) );
    /* Can't reclaim as long as nothing's provided. */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) ==
                 MBEDTLS_ERR_WRITER_UNEXPECTED_OPERATION );
    /* Feed some buffer to the writer */
    TEST_ASSERT( mbedtls_writer_feed( &wr, buf, sizeof( buf ) ) == 0 );
    /* Can't feed again as we're now in producing mode */
    TEST_ASSERT( mbedtls_writer_feed( &wr, buf, sizeof( buf ) ) == 0
                 MBEDTLS_ERR_WRITER_UNEXPECTED_OPERATION );
    /* Producing (upper layer) */
    /* Fetch and write to the entire output buffer */
    TEST_ASSERT( mbedtls_writer_get( &wr, 100, &tmp, NULL ) == 0 );
    memcpy( tmp, out, 100 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );

    /* Wrapup (lower layer) */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) == 0 );
    mbedtls_writer_free( &wr );

    TEST_ASSERT( memcmp( buf, out, 100 ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_WRITER */
void mbedtls_mps_writer_unexpected_operations()
{
    /* Unexpected operations shouldn't corrupt any internal structures.
     * This test checks this by exercising a simple writer test with
     * queueing and inserting multiple unexpected calls in between. */
    unsigned char bufA[100], bufB[100];
    unsigned char outA[100], outB[100];
    unsigned char queue[20];
    unsigned char *tmp;
    mbedtls_mps_size_t olen;
    mbedtls_writer wr;

    for( int i=0; (unsigned) i < 100; i++ )
        outA[i] = (unsigned char) i;
    for( int i=0; (unsigned) i < 100; i++ )
        outB[i] = ~ (unsigned char) i;

    /* Provisioning (lower layer) */
    mbedtls_writer_init( &wr, queue, sizeof( queue ) );
    /* Can't reclaim as long as nothing's provided. */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) ==
                 MBEDTLS_ERR_WRITER_UNEXPECTED_OPERATION );
    /* Can't get or commit anything as long as nothing's provided. */
    TEST_ASSERT( mbedtls_writer_get( &wr, 100, &tmp, NULL ) ==
                 MBEDTLS_ERR_WRITER_UNEXPECTED_OPERATION );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) ==
                 MBEDTLS_ERR_WRITER_UNEXPECTED_OPERATION );
    /* Feed some buffer to the writer */
    TEST_ASSERT( mbedtls_writer_feed( &wr, bufA, sizeof( bufA ) ) == 0 );
    /* Can't feed again as we're now in producing mode */
    TEST_ASSERT( mbedtls_writer_feed( &wr, bufA, sizeof( bufA ) ) == 0
                 MBEDTLS_ERR_WRITER_UNEXPECTED_OPERATION );
    /* Producing (upper layer) */
    TEST_ASSERT( mbedtls_writer_get( &wr, 90, &tmp, NULL ) == 0 );
    memcpy( tmp, outA, 90 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    /* Test the committing again has no effect. */
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 20, &tmp, NULL ) == 0 );
    memcpy( tmp, outA + 90, 10 );
    memcpy( tmp + 10, outB, 10 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    /* Test the committing again has no effect. */
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    /* Provisioning */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, &olen, NULL, 0 ) == 0 );
    TEST_ASSERT( olen == 100 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 100, &tmp, NULL ) ==
                 MBEDTLS_ERR_WRITER_UNEXPECTED_OPERATION );
    TEST_ASSERT( mbedtls_writer_feed( &wr, bufB, sizeof( bufB ) ) == 0 );
    /* Providing */
    TEST_ASSERT( mbedtls_writer_get( &wr, 90, &tmp, NULL ) == 0 );
    memcpy( tmp, outB + 10, 90 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    /* Wrapup */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, &olen, NULL, 0 ) == 0 );
    TEST_ASSERT( olen == 100 );
    mbedtls_writer_free( &wr );

    TEST_ASSERT( memcmp( bufA, outA, 100 ) == 0 );
    TEST_ASSERT( memcmp( bufB, outB, 100 ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_WRITER */
void mbedtls_mps_writer_no_queueing_single_step_multiple_rounds( int with_queue )
{
    /* Multiple rounds of lower layer providing space
     * for outgoing data to be written to, and upper layer
     * fetches and writes it in a single go. */
    unsigned char bufA[100], bufB[100];
    unsigned char outA[100], outB[100];
    unsigned char queue[10];
    unsigned char *tmp;
    mbedtls_writer wr;
    for( int i=0; (unsigned) i < sizeof( outA ); i++ )
        outA[i] = (unsigned char) i;
    for( int i=0; (unsigned) i < sizeof( outB ); i++ )
        outB[i] = ~ ((unsigned char) i);

    /* Provisioning (lower layer) */
    if( with_queue == 0 )
        mbedtls_writer_init( &wr, NULL, 0 );
    else
        mbedtls_writer_init( &wr, queue, sizeof( queue ) );
    TEST_ASSERT( mbedtls_writer_feed( &wr, bufA, sizeof( bufA ) ) == 0 );
    /* Producing (upper layer) */
    /* Consume exactly what's available */
    TEST_ASSERT( mbedtls_writer_get( &wr, 100, &tmp, NULL ) == 0 );
    memcpy( tmp, outA, 100 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    /* Provisioning */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) == 0 );
    TEST_ASSERT( mbedtls_writer_feed( &wr, bufB, sizeof( bufB ) ) == 0 );
    /* Producing */
    TEST_ASSERT( mbedtls_writer_get( &wr, 100, &tmp, NULL ) == 0 );
    memcpy( tmp, outB, 100 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    /* Wrapup (lower layer) */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) == 0 );
    mbedtls_writer_free( &wr );

    TEST_ASSERT( memcmp( bufA, outA, 100 ) == 0 );
    TEST_ASSERT( memcmp( bufB, outB, 100 ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_WRITER */
void mbedtls_mps_writer_no_queueing_multiple_steps_single_round( int with_queue )
{
    /* Lower layer provides output buffer that the upper layer
     * fetches and writes to in multiple `get` calls. */
    unsigned char buf[100];
    unsigned char out[100];
    unsigned char queue[10];
    unsigned char *tmp;
    mbedtls_mps_size_t tmp_len;
    mbedtls_writer wr;
    for( int i=0; (unsigned) i < sizeof( out ); i++ )
        out[i] = (unsigned char) i;

    /* Provisioning (lower layer) */
    if( with_queue == 0 )
        mbedtls_writer_init( &wr, NULL, 0 );
    else
        mbedtls_writer_init( &wr, queue, sizeof( queue ) );
    TEST_ASSERT( mbedtls_writer_feed( &wr, buf, sizeof( buf ) ) == 0 );
    /* Producing (upper layer) */
    TEST_ASSERT( mbedtls_writer_get( &wr, 10, &tmp, NULL ) == 0 );
    memcpy( tmp, out, 10 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 70, &tmp, NULL ) == 0 );
    memcpy( tmp, out + 10, 70 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 30, &tmp, &tmp_len ) == 0 );
    TEST_ASSERT( tmp_len == 20 );
    memcpy( tmp, out + 80, 20 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    /* Wrapup (lower layer) */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) == 0 );
    mbedtls_writer_free( &wr );

    TEST_ASSERT( memcmp( buf, out, 100 ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_WRITER */
void mbedtls_mps_writer_no_queueing_multiple_steps_multiple_rounds( int with_queue )
{
    /* Repeat lower layer providing output buffer that the upper layer
     * fetches and writes to in multiple `get` calls. */
    unsigned char bufA[100], bufB[100];
    unsigned char outA[100], outB[100];
    unsigned char queue[10];
    unsigned char *tmp;
    mbedtls_mps_size_t tmp_len;
    mbedtls_writer wr;
    for( int i=0; (unsigned) i < sizeof( outA ); i++ )
        outA[i] = (unsigned char) i;
    for( int i=0; (unsigned) i < sizeof( outB ); i++ )
        outB[i] = ~ ((unsigned char) i);

    /* Provisioning (lower layer) */
    if( with_queue == 0 )
        mbedtls_writer_init( &wr, NULL, 0 );
    else
        mbedtls_writer_init( &wr, queue, sizeof( queue ) );
    TEST_ASSERT( mbedtls_writer_feed( &wr, bufA, sizeof( bufA ) ) == 0 );
    /* Producing (upper layer) */
    TEST_ASSERT( mbedtls_writer_get( &wr, 10, &tmp, NULL ) == 0 );
    memcpy( tmp, outA, 10 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 70, &tmp, NULL ) == 0 );
    memcpy( tmp, outA + 10, 70 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 30, &tmp, &tmp_len ) == 0 );
    TEST_ASSERT( tmp_len == 20 );
    memcpy( tmp, outA + 80, 20 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    /* Provisioning */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) == 0 );
    TEST_ASSERT( mbedtls_writer_feed( &wr, bufB, sizeof( bufB ) ) == 0 );
    /* Producing */
    TEST_ASSERT( mbedtls_writer_get( &wr, 100, &tmp, NULL ) == 0 );
    memcpy( tmp, outB, 100 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    /* Wrapup */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) == 0 );
    mbedtls_writer_free( &wr );

    TEST_ASSERT( memcmp( outA, bufA, 100 ) == 0 );
    TEST_ASSERT( memcmp( outB, bufB, 100 ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_WRITER */
void mbedtls_mps_writer_no_queueing_multiple_steps_multiple_rounds_partial_commit( int with_queue )
{
    /* Almost identical to multiple_steps_multiple_rounds_no_commit,
     * but only partially comitting writes in first round. */
    unsigned char bufA[100], bufB[100];
    unsigned char outA[100], outB[100];
    unsigned char queue[10];
    unsigned char *tmp;
    mbedtls_mps_size_t tmp_len;
    mbedtls_writer wr;
    for( int i=0; (unsigned) i < sizeof( outA ); i++ )
        outA[i] = (unsigned char) i;
    for( int i=0; (unsigned) i < sizeof( outB ); i++ )
        outB[i] = ~ ((unsigned char) i);

    /* Provisioning (lower layer) */
    if( with_queue == 0 )
        mbedtls_writer_init( &wr, NULL, 0 );
    else
        mbedtls_writer_init( &wr, queue, sizeof( queue ) );
    TEST_ASSERT( mbedtls_writer_feed( &wr, bufA, sizeof( bufA ) ) == 0 );
    /* Producing (upper layer) */
    TEST_ASSERT( mbedtls_writer_get( &wr, 10, &tmp, NULL ) == 0 );
    memcpy( tmp, outA, 10 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 70, &tmp, NULL ) == 0 );
    memcpy( tmp, outA + 10, 70 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 30, &tmp, &tmp_len ) == 0 );
    TEST_ASSERT( tmp_len == 20 );
    memcpy( tmp, outA + 80, 20 );
    /* Provisioning */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 1 /*force*/ ) == 0 );
    TEST_ASSERT( mbedtls_writer_feed( &wr, bufB, sizeof( bufB ) ) == 0 );
    /* Producing */
    TEST_ASSERT( mbedtls_writer_get( &wr, 100, &tmp, NULL ) == 0 );
    memcpy( tmp, outB, 100 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    /* Wrapup */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) == 0 );
    mbedtls_writer_free( &wr );

    TEST_ASSERT( memcmp( outA, bufA, 80  ) == 0 );
    TEST_ASSERT( memcmp( outB, bufB, 100 ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_WRITER */
void mbedtls_mps_writer_queue_needed_disabled()
{
    /* If a write request goes beyond the provided output buffer
     * and queueing is not used, signal OUT_OF_DATA. */
    unsigned char buf[100];
    unsigned char out[100];
    unsigned char *tmp;
    mbedtls_writer wr;
    for( int i=0; (unsigned) i < sizeof( out ); i++ )
        out[i] = (unsigned char) i;

    /* Preparation (lower layer) */
    mbedtls_writer_init( &wr, NULL, 0 );
    TEST_ASSERT( mbedtls_writer_feed( &wr, buf, sizeof( buf ) ) == 0 );
    /* Consumption (upper layer) */
    TEST_ASSERT( mbedtls_writer_get( &wr, 50, &tmp, NULL ) == 0 );
    memcpy( tmp, out, 50 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 100, &tmp, NULL ) ==
                 MBEDTLS_ERR_WRITER_OUT_OF_DATA );
    /* Wrapup (lower layer) */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) ==
                 MBEDTLS_ERR_WRITER_DATA_LEFT );
    mbedtls_writer_free( &wr );
    TEST_ASSERT( memcmp( buf, out, 50 ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_WRITER */
void mbedtls_mps_writer_queue_needed_too_small()
{
    /* If a write request goes beyond the provided output buffer
     * and queueing is used but the queue is too small, signal OUT_OF_DATA. */
    unsigned char buf[100];
    unsigned char out[100];
    unsigned char queue[10];
    unsigned char *tmp;
    mbedtls_writer wr;
    for( int i=0; (unsigned) i < sizeof( out ); i++ )
        out[i] = (unsigned char) i;

    /* Provisioning (lower layer) */
    mbedtls_writer_init( &wr, queue, sizeof( queue ) );
    TEST_ASSERT( mbedtls_writer_feed( &wr, buf, sizeof( buf ) ) == 0 );
    /* Producing (upper layer) */
    TEST_ASSERT( mbedtls_writer_get( &wr, 50, &tmp, NULL ) == 0 );
    memcpy( tmp, out, 50 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 100, &tmp, NULL ) ==
                 MBEDTLS_ERR_WRITER_OUT_OF_DATA );
    /* Wrapup (lower layer) */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) ==
                 MBEDTLS_ERR_WRITER_DATA_LEFT );
    mbedtls_writer_free( &wr );
    TEST_ASSERT( memcmp( buf, out, 50 ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_WRITER */
void mbedtls_mps_writer_queue_basic( int commit )
{
    unsigned char bufA[100], bufB[100];
    unsigned char outA[100], outB[100];
    unsigned char queue[20];
    unsigned char *tmp;
    mbedtls_writer wr;
    for( int i=0; (unsigned) i < sizeof( outA ); i++ )
        outA[i] = (unsigned char) i;
    for( int i=0; (unsigned) i < sizeof( outB ); i++ )
        outB[i] = ~ ((unsigned char) i);

    /* Provisioning (lower layer) */
    mbedtls_writer_init( &wr, queue, sizeof( queue ) );
    TEST_ASSERT( mbedtls_writer_feed( &wr, bufA, sizeof( bufA ) ) == 0 );
    /* Producing (upper layer) */
    TEST_ASSERT( mbedtls_writer_get( &wr, 90, &tmp, NULL ) == 0 );
    memcpy( tmp, outA, 90 );
    if( commit == 1 )
        TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 20, &tmp, NULL ) == 0 );
    memcpy( tmp, outA + 90, 10 );
    memcpy( tmp + 10, outB, 10 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 90, &tmp, NULL ) ==
                 MBEDTLS_ERR_WRITER_OUT_OF_DATA );
    /* Provisioning */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) == 0 );
    TEST_ASSERT( mbedtls_writer_feed( &wr, bufB, sizeof( bufB ) ) == 0 );
    /* Producing */
    TEST_ASSERT( mbedtls_writer_get( &wr, 90, &tmp, NULL ) == 0 );
    memcpy( tmp, outB + 10, 90 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    /* Wrapup (lower layer) */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) == 0 );
    mbedtls_writer_free( &wr );
    TEST_ASSERT( memcmp( bufA, outA, 100 ) == 0 );
    TEST_ASSERT( memcmp( bufB, outB, 100 ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_WRITER */
void mbedtls_mps_writer_queue_boundary()
{
    /* This test exercises the behavior of the writer
     * when a write-request is made after the entire
     * output buffer has been requested and committed.
     * There are two ways to handle this in the implementation:
     * 1. Reject the request, indicating that not enough data is available.
     * 2. Attempt to serve the request from the accumulator.
     * Currently, the implementation follows behavior 2,
     * and the test checks for that. */

    unsigned char bufA[100], bufB[100];
    unsigned char outA[100], outB[100];
    unsigned char queue[20];

    unsigned char *tmp;
    mbedtls_writer wr;
    for( int i=0; (unsigned) i < sizeof( outA ); i++ )
        outA[i] = (unsigned char) i;
    for( int i=0; (unsigned) i < sizeof( outB ); i++ )
        outB[i] = ~ ((unsigned char) i);

    /* Provisioning (lower layer) */
    mbedtls_writer_init( &wr, queue, sizeof( queue ) );
    TEST_ASSERT( mbedtls_writer_feed( &wr, bufA, sizeof( bufA ) ) == 0 );
    /* Producing (upper layer) */
    TEST_ASSERT( mbedtls_writer_get( &wr, sizeof( bufA ), &tmp, NULL ) == 0 );
    memcpy( tmp, outA, sizeof( bufA ) );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    /* In behavior 2, the following write-request
     * will be served from the queue. */
    TEST_ASSERT( mbedtls_writer_get( &wr, sizeof( queue ), &tmp, NULL ) == 0 );
    memcpy( tmp, outB, sizeof( queue ) );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 1, &tmp, NULL ) ==
                 MBEDTLS_ERR_WRITER_OUT_OF_DATA );
    /* Provisioning */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) == 0 );
    TEST_ASSERT( mbedtls_writer_feed( &wr, bufB, sizeof( bufB ) ) == 0 );
    /* Wrapup (lower layer) */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 1 ) == 0 );
    mbedtls_writer_free( &wr );
    TEST_ASSERT( memcmp( bufA, outA, sizeof( bufA ) ) == 0 );
    TEST_ASSERT( memcmp( bufB, outB, sizeof( queue ) ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_WRITER */
void mbedtls_mps_writer_queue_multiple_requests( int commit )
{
    /* This test exercises the behavior of the writer
     * when multiple requests are served from the queue. */

    unsigned char bufA[100], bufB[100];
    unsigned char outA[100], outB[100];
    unsigned char queue[40];
    unsigned char *tmp;
    mbedtls_writer wr;
    for( int i=0; (unsigned) i < sizeof( outA ); i++ )
        outA[i] = (unsigned char) i;
    for( int i=0; (unsigned) i < sizeof( outB ); i++ )
        outB[i] = ~ ((unsigned char) i);

    /* Provisioning (lower layer) */
    mbedtls_writer_init( &wr, queue, sizeof( queue ) );
    TEST_ASSERT( mbedtls_writer_feed( &wr, bufA, sizeof( bufA ) ) == 0 );
    /* Producing (upper layer) */
    TEST_ASSERT( mbedtls_writer_get( &wr, 90, &tmp, NULL ) == 0 );
    memcpy( tmp, outA, 90 );
    if( commit )
        TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 20, &tmp, NULL ) == 0 );
    memcpy( tmp, outA + 90, 10 );
    memcpy( tmp + 10, outB, 10 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 90, &tmp, NULL ) ==
                 MBEDTLS_ERR_WRITER_OUT_OF_DATA );
    TEST_ASSERT( mbedtls_writer_get( &wr, 10, &tmp, NULL ) == 0 );
    memcpy( tmp, outB + 10, 10 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    /* Provisioning */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) == 0 );
    TEST_ASSERT( mbedtls_writer_feed( &wr, bufB, sizeof( bufB ) ) == 0 );
    /* Producing */
    TEST_ASSERT( mbedtls_writer_get( &wr, 80, &tmp, NULL ) == 0 );
    memcpy( tmp, outB + 20, 80 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    /* Wrapup (lower layer) */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) == 0 );
    mbedtls_writer_free( &wr );
    TEST_ASSERT( memcmp( bufA, outA, 100 ) == 0 );
    TEST_ASSERT( memcmp( bufB, outB, 100 ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_WRITER */
void mbedtls_mps_writer_queue_multiple_refeed()
{
    /* Test situation where multiple output buffers are
     * needed to hold the queued outbound data. */
    unsigned char bufA[100], bufB[100];
    unsigned char outA[100], outB[100];
    unsigned char queue[20];
    unsigned char *tmp;
    mbedtls_writer wr;
    for( int i=0; (unsigned) i < sizeof( outA ); i++ )
    {
        bufA[i] = 0;
        outA[i] = (unsigned char) i;
    }
    for( int i=0; (unsigned) i < sizeof( outB ); i++ )
    {
        bufB[i] = 0;
        outB[i] = ~ ((unsigned char) i);
    }

    /* Provisioning (lower layer) */
    mbedtls_writer_init( &wr, queue, sizeof( queue ) );
    TEST_ASSERT( mbedtls_writer_feed( &wr, bufA, sizeof( bufA ) ) == 0 );
    /* Producing (upper layer) */
    TEST_ASSERT( mbedtls_writer_get( &wr, 90, &tmp, NULL ) == 0 );
    memcpy( tmp, outA, 90 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 20, &tmp, NULL ) == 0 );
    memcpy( tmp, outA + 90, 10 );
    memcpy( tmp + 10, outB, 10 );
    /* So far we have been writing to the queue, and the results
     * are not partially copied to the output buffer until the buffer is reclaimed. */
    TEST_ASSERT( memcmp( bufA, outA, 100 ) != 0 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 90, &tmp, NULL ) ==
                 MBEDTLS_ERR_WRITER_OUT_OF_DATA );
    /* Provisioning */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) == 0 );
    /* Now they should be there. */
    TEST_ASSERT( memcmp( bufA, outA, 100 ) == 0 );
    for( int i=0; i<9; i++ )
    {
        TEST_ASSERT( mbedtls_writer_feed( &wr, bufB + i, 1 ) ==
                     MBEDTLS_ERR_WRITER_NEED_MORE );
    }
    TEST_ASSERT( mbedtls_writer_feed( &wr, bufB + 9, 91 ) == 0 );
    /* Producing */
    TEST_ASSERT( mbedtls_writer_get( &wr, 90, &tmp, NULL ) == 0 );
    memcpy( tmp, outB + 10, 90 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    /* Wrapup (lower layer) */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) == 0 );
    mbedtls_writer_free( &wr );
    TEST_ASSERT( memcmp( bufA, outA, 100 ) == 0 );
    TEST_ASSERT( memcmp( bufB, outB, 100 ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_WRITER */
void mbedtls_mps_writer_queue_multiple_rounds()
{
    /* Exercise three rounds of feed-get-commit-reclaim, with queueing. */
    unsigned char bufA[100], bufB[100], bufC[100];
    unsigned char outA[100], outB[100], outC[100];
    unsigned char queue[20];
    unsigned char *tmp;
    mbedtls_writer wr;
    for( int i=0; (unsigned) i < sizeof( outA ); i++ )
        outA[i] = (unsigned char) i;
    for( int i=0; (unsigned) i < sizeof( outB ); i++ )
        outB[i] = ~ ((unsigned char) i);
    for( int i=0; (unsigned) i < sizeof( outC ); i++ )
        outC[i] = (unsigned char)( 128 + i );

    /* Provisioning (lower layer) */
    mbedtls_writer_init( &wr, queue, sizeof( queue ) );
    TEST_ASSERT( mbedtls_writer_feed( &wr, bufA, sizeof( bufA ) ) == 0 );
    /* Producing (upper layer) */
    TEST_ASSERT( mbedtls_writer_get( &wr, 90, &tmp, NULL ) == 0 );
    memcpy( tmp, outA, 90 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 20, &tmp, NULL ) == 0 );
    memcpy( tmp, outA + 90, 10 );
    memcpy( tmp + 10, outB, 10 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 90, &tmp, NULL ) ==
                 MBEDTLS_ERR_WRITER_OUT_OF_DATA );
    /* Provisioning */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) == 0 );
    TEST_ASSERT( mbedtls_writer_feed( &wr, bufB, sizeof( bufB ) ) == 0 );
    /* Producing */
    TEST_ASSERT( mbedtls_writer_get( &wr, 80, &tmp, NULL ) == 0 );
    memcpy( tmp, outB + 10, 80 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 20, &tmp, NULL ) == 0 );
    memcpy( tmp, outB + 90, 10 );
    memcpy( tmp + 10, outC, 10 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 90, &tmp, NULL ) ==
                 MBEDTLS_ERR_WRITER_OUT_OF_DATA );
    /* Provisioning */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) == 0 );
    TEST_ASSERT( mbedtls_writer_feed( &wr, bufC, sizeof( bufC ) ) == 0 );
    /* Producing */
    TEST_ASSERT( mbedtls_writer_get( &wr, 90, &tmp, NULL ) == 0 );
    memcpy( tmp, outC + 10, 90 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    /* Wrapup (lower layer) */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) == 0 );
    mbedtls_writer_free( &wr );
    TEST_ASSERT( memcmp( bufA, outA, 100 ) == 0 );
    TEST_ASSERT( memcmp( bufB, outB, 100 ) == 0 );
    TEST_ASSERT( memcmp( bufC, outC, 100 ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_WRITER */
void mbedtls_mps_writer_random_usage( int data_amount,
                                      int max_chunk_size,
                                      int max_request,
                                      int queue_size )

{
    /* Randomly pass a writer object back and forth between lower and
     * upper layer and let each of them call the respective writer API
     * functions in a random fashion.
     *
     * On the lower layer, we're tracking and concatenating
     * the data passed to successful reclaim calls.
     *
     * For the upper layer, we track and concatenate buffers
     * obtained from successful commit calls.
     *
     * As long as the lower layer calls reclaim at least once, (resetting the
     * fetched but not-yet-committed data), this should always lead to the same
     * stream of outgoing/incoming data for the lower/upper layers, even if
     * most of the random calls fail.
     *
     * NOTE: This test uses rand() for random data, which is not optimal.
     *       Instead, it would be better to get the random data from a
     *       static buffer. This both eases reproducibility and allows
     *       simple conversion to a fuzz target.
     */
    int ret;
    unsigned char *queue = NULL;
    unsigned char *outgoing, *incoming;
    unsigned char *cur_chunk = NULL;
    mbedtls_mps_size_t cur_out_chunk_size, out_pos, in_commit, in_fetch;
    int rand_op;  /* Lower layer:
                   * - Reclaim (0)
                   * - Feed (1)
                   * Upper layer:
                   * - Get, do tolerate smaller output (0)
                   * - Get, don't tolerate smaller output (1)
                   * - Commit (2) */
    int mode = 0; /* Lower layer (0) or Upper layer (1) */
    int reclaimed = 1; /* Have to call reclaim at least once before
                        * returning the reader to the upper layer. */
    int force;
    mbedtls_writer wr;

    unsigned seed;

    if( queue_size > 0 )
    {
        queue = malloc( queue_size );
        TEST_ASSERT( queue != NULL );
    }

    /* This probably needs to be changed because we want
     * our tests to be deterministic. */
    seed = time( NULL ); // 1522933016;
    srand( seed );

    outgoing = malloc( data_amount );
    incoming = malloc( data_amount );

    TEST_ASSERT( outgoing != NULL );
    TEST_ASSERT( incoming != NULL );

    mbedtls_writer_init( &wr, queue, queue_size );

    cur_out_chunk_size = 0;
    in_commit = 0;
    in_fetch = 0;
    out_pos = 0;
    while( out_pos < (unsigned) data_amount )
    {
        if( mode == 0 )
        {
            /* Choose randomly between reclaim and feed */
            rand_op = rand() % 3;

            if( rand_op == 0 || rand_op == 1 )
            {
                mbedtls_mps_size_t out_committed;

                /* Reclaim */

                if( cur_out_chunk_size > out_pos - (unsigned) data_amount )
                    force = 1;
                else
                    force = ( rand_op == 0 );

                if( force == 1 )
                {
                    ret = mbedtls_writer_reclaim( &wr, &out_committed,
                                                  NULL, 1 );
                }
                else
                {
                    ret = mbedtls_writer_reclaim( &wr, NULL, NULL, 0 );
                    out_committed = cur_out_chunk_size;
                }

                TEST_ASSERT( ! ( force == 1 &&
                                 ret == MBEDTLS_ERR_WRITER_DATA_LEFT ) );

                if( ret == 0 )
                {
                    TEST_ASSERT( out_committed <= cur_out_chunk_size );
                    TEST_ASSERT( cur_chunk != NULL );
                    memcpy( outgoing + out_pos, cur_chunk, out_committed );
                    out_pos += out_committed;

                    free( cur_chunk );
                    cur_chunk = NULL;
                }
                reclaimed = 1;
            }
            else
            {
                /* Feed writer another outgoing data chunk */
                unsigned char *tmp;
                mbedtls_mps_size_t tmp_size;

                tmp_size = ( rand() % max_chunk_size ) + 1;
                tmp = malloc( tmp_size );
                TEST_ASSERT( tmp != NULL );

                ret = mbedtls_writer_feed( &wr, tmp, tmp_size );

                if( ret == MBEDTLS_ERR_WRITER_NEED_MORE )
                {
                    /* Outgoing data chunk has been entirely written
                     * from the queue. */
                    memcpy( outgoing + out_pos, tmp, tmp_size );
                    out_pos += tmp_size;
                }

                if( ret == 0 )
                {
                    cur_chunk = tmp;
                    cur_out_chunk_size = tmp_size;
                }
                else
                {
                    free( tmp );
                }
            }

            /* Randomly switch to consumption mode if reclaim
             * was called at least once. */
            if( reclaimed == 1 && rand() % 3 == 0 )
            {
                in_fetch = 0;
                mode = 1;
            }
        }
        else
        {
            /* Choose randomly between get tolerating fewer data,
             * get not tolerating fewer data, and commit. */
            rand_op = rand() % 3;
            if( rand_op == 0 || rand_op == 1 )
            {
                mbedtls_mps_size_t get_size, real_size;
                unsigned char *chunk_get;
                get_size = ( rand() % max_request ) + 1;
                if( get_size > data_amount - ( in_commit + in_fetch ) )
                    get_size = data_amount - in_commit - in_fetch;

                if( rand_op == 0 )
                {
                    ret = mbedtls_writer_get( &wr, get_size, &chunk_get,
                                              &real_size );
                }
                else
                {
                    real_size = get_size;
                    ret = mbedtls_writer_get( &wr, get_size, &chunk_get, NULL );
                }

                if( ret == 0 )
                {
                    /* Fill output buffer with random data. */
                    rnd_std_rand( NULL, incoming + in_commit + in_fetch, real_size );
                    memcpy( chunk_get, incoming + in_commit + in_fetch, real_size );
                    in_fetch += real_size;
                }
                else if( ret == MBEDTLS_ERR_WRITER_OUT_OF_DATA )
                {
                    TEST_ASSERT( (mbedtls_mps_size_t)( in_commit + in_fetch + get_size ) >
                                 (mbedtls_mps_size_t) queue_size );
                }
            }
            else if( rand_op == 2 ) /* Commit */
            {
                mbedtls_mps_size_t omit=0;

                /* Leave a change to omit more than what was
                 * fetched since the last commit. */
                omit = rand() % ( 2 * in_fetch + 1 );

                ret = mbedtls_writer_commit_partial( &wr, omit );
                if( omit > in_fetch )
                    TEST_ASSERT( ret ==  MBEDTLS_ERR_WRITER_INVALID_ARG );

                if( ret == 0 )
                {
                    in_commit += in_fetch - omit;
                    in_fetch = 0;
                }
            }

            /* Randomly switch back to preparation */
            if( rand() % 3 == 0 )
            {
                reclaimed = 0;
                mode = 0;
            }
        }
    }

    /* Compare results. */
    TEST_ASSERT( in_commit == (unsigned) data_amount );
    TEST_ASSERT( memcmp( outgoing, incoming, data_amount ) == 0 );

    /* Cleanup */
    mbedtls_writer_free( &wr );
    free( incoming );
    free( outgoing );
    free( queue );
    free( cur_chunk );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_L1 */
void mbedtls_mps_l1_basic( int send_multiple,
                           int send_multiple_do_flush,
                           int recv_multiple,
                           int recv_multiple_do_consume )
{
    mps_alloc cli_alloc, srv_alloc;
    mps_l1 cli, srv;

    /* This test exercises a client sending a chunk of
     * data to the server in one or multiple chunks (as
     * determined by `send_multiple`), and the server reading
     * it in one or multiple chunks (as determined by
     * `recv_multiple`).
     * If `send_multiple_do_flush` is set in addition to
     * `send_multiple`, the client flushes Layer 1 after
     * each chunk has been sent.
     * If `recv_multiple_do_consume` is set in addition to
     * `recv_multiple`, the server consumes each chunk
     * after it has read it.
     */

    unsigned char data[100];
    unsigned char data_in[100];
    size_t const data_len = sizeof( data );
    size_t send_chunk_size = 10; /* Size of outgoing chunks in the
                                  * multiple-send-chunk case. */
    size_t recv_chunk_size = 10; /* Size of incoming chunks in the
                                  * multiple-recv-chunk case. */
    unsigned char *out_buf;
    unsigned char *in_buf;
    size_t out_len;

    /* Initialize Layer 0 mock objects */
    layer0_bufsize = (size_t) data_len;
    TEST_ASSERT( layer0_init( &s2c ) == 0 );
    TEST_ASSERT( layer0_init( &c2s ) == 0 );

    /* Initialize allocators */
    mps_alloc_init( &cli_alloc, data_len );
    mps_alloc_init( &srv_alloc, data_len );

    /* Initialize Layer 1 */
    TEST_ASSERT( mps_l1_init( &cli, MPS_L1_MODE_STREAM, &cli_alloc,
                              layer0_write_cli, layer0_read_cli ) == 0 );
    TEST_ASSERT( mps_l1_init( &srv, MPS_L1_MODE_STREAM, &srv_alloc,
                              layer0_write_srv, layer0_read_srv ) == 0 );

    /* Generate the random content to be exchanged */
    TEST_ASSERT( rnd_std_rand( NULL, data, data_len ) == 0 );

    /* Step 1: Send data from client to server,
     *         either in a single or in multiple chunks. */
    if( ! send_multiple )
    {
        /* Send data in a single chunk. */
        TEST_ASSERT( mps_l1_write( &cli, &out_buf, &out_len ) == 0 );

        /* The allocator is configured so that it should return
         * a buffer large enough to hold all data to be sent. */
        TEST_ASSERT( out_len >= data_len );

        memcpy( out_buf, data, data_len );

        /* Dispatch data in one go. */
        TEST_ASSERT( mps_l1_dispatch( &cli, data_len ) == 0 );
        TEST_ASSERT( mps_l1_flush( &cli ) == 0 );
    }
    else
    {
        /* Send data in multiple chunks of size `send_chunk_size` each. */
        TEST_ASSERT( data_len % send_chunk_size == 0 );
        for( size_t idx=0; idx < data_len; idx += send_chunk_size )
        {
            /* Send data in a single chunk. */
            TEST_ASSERT( mps_l1_write( &cli, &out_buf, &out_len ) == 0 );

            /* The allocator is configured so that it should return
             * a buffer large enough to hold all data to be sent. */
            TEST_ASSERT( out_len >= send_chunk_size );

            memcpy( out_buf, data + idx, send_chunk_size );

            TEST_ASSERT( mps_l1_dispatch( &cli, send_chunk_size ) == 0 );
            if( send_multiple_do_flush )
                TEST_ASSERT( mps_l1_flush( &cli ) == 0 );
        }

        if( ! send_multiple_do_flush )
            TEST_ASSERT( mps_l1_flush( &cli ) == 0 );
    }

    /* Step 2: Receive data on the server,
     *         either in a single or in multiple chunks. */
    if( ! recv_multiple )
    {
        /* Receive in a single chunk. */
        TEST_ASSERT( mps_l1_fetch( &srv, &in_buf, data_len ) == 0 );
        memcpy( data_in, in_buf, data_len );
        TEST_ASSERT( mps_l1_consume( &srv ) == 0 );
    }
    else
    {
        /* Receive in multiple chunks. */
        TEST_ASSERT( data_len % recv_chunk_size == 0 );
        for( size_t idx=0; idx < data_len; idx += recv_chunk_size )
        {
            if( recv_multiple_do_consume )
            {
                TEST_ASSERT( mps_l1_fetch( &srv, &in_buf, recv_chunk_size ) == 0 );
                memcpy( data_in + idx, in_buf, recv_chunk_size );
                TEST_ASSERT( mps_l1_consume( &srv ) == 0 );
            }
            else
            {
                TEST_ASSERT( mps_l1_fetch( &srv, &in_buf, idx + recv_chunk_size ) == 0 );
                memcpy( data_in + idx, in_buf + idx, recv_chunk_size );
            }
        }

        if( ! recv_multiple_do_consume )
            TEST_ASSERT( mps_l1_consume( &srv ) == 0 );
    }

    TEST_ASSERT( memcmp( data_in, data, data_len ) == 0 );

    TEST_ASSERT( mps_l1_free( &cli ) == 0 );
    TEST_ASSERT( mps_l1_free( &srv ) == 0 );

    TEST_ASSERT( mps_alloc_free( &cli_alloc ) == 0 );
    TEST_ASSERT( mps_alloc_free( &srv_alloc ) == 0 );

    layer0_free( &s2c );
    layer0_free( &c2s );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_L1 */
void mbedtls_mps_l1_want_read( )
{
    mps_alloc cli_alloc, srv_alloc;
    mps_l1 cli, srv;

    /* This test exercises the behavior of the receiving
     * side of Layer 1 if the underlying stream transport
     * cannot provide enough incoming data.
     * Concretely:
     * 1. Client sends 10 bytes.
     * 2. Server requests 20 bytes, observing a WANT_READ.
     * 3. Client sends another 10 bytes.
     * 4. Server retries, this time successfully.
     */

    unsigned char data[20];
    size_t const data_len = sizeof( data );
    unsigned char *out_buf;
    unsigned char *in_buf;
    size_t out_len;

    /* Initialize Layer 0 mock objects */
    layer0_bufsize = (size_t) data_len;
    TEST_ASSERT( layer0_init( &s2c ) == 0 );
    TEST_ASSERT( layer0_init( &c2s ) == 0 );

    /* Initialize allocators */
    mps_alloc_init( &cli_alloc, data_len );
    mps_alloc_init( &srv_alloc, data_len );

    /* Initialize Layer 1 */
    TEST_ASSERT( mps_l1_init( &cli, MPS_L1_MODE_STREAM, &cli_alloc,
                              layer0_write_cli, layer0_read_cli ) == 0 );
    TEST_ASSERT( mps_l1_init( &srv, MPS_L1_MODE_STREAM, &srv_alloc,
                              layer0_write_srv, layer0_read_srv ) == 0 );

    /* Generate the random content to be exchanged */
    TEST_ASSERT( rnd_std_rand( NULL, data, data_len ) == 0 );

    /* Step 1: Client sends first half of bytes. */
    TEST_ASSERT( mps_l1_write( &cli, &out_buf, &out_len ) == 0 );

    /* The allocator is configured so that it should return
     * a buffer large enough to hold all data to be sent. */
    TEST_ASSERT( out_len == data_len );
    memcpy( out_buf, data, data_len / 2 );

    TEST_ASSERT( mps_l1_dispatch( &cli, data_len / 2 ) == 0 );
    TEST_ASSERT( mps_l1_flush( &cli ) == 0 );

    /* Step 2: Receive data on the server,
     *         either in a single or in multiple chunks. */

    TEST_ASSERT( mps_l1_fetch( &srv, &in_buf, data_len ) ==
                 MPS_ERR_WANT_READ );

    /* Step 3: Client sends second half of bytes. */
    TEST_ASSERT( mps_l1_write( &cli, &out_buf, &out_len ) == 0 );

    /* The allocator is configured so that it should return
     * a buffer large enough to hold all data to be sent. */
    TEST_ASSERT( out_len == data_len );
    memcpy( out_buf, data + ( data_len / 2 ), data_len /2 );

    TEST_ASSERT( mps_l1_dispatch( &cli, data_len / 2 ) == 0 );
    TEST_ASSERT( mps_l1_flush( &cli ) == 0 );

    /* Step 4: Server retries, this time successfully. */

    TEST_ASSERT( mps_l1_fetch( &srv, &in_buf, data_len ) == 0 );
    TEST_ASSERT( memcmp( in_buf, data, data_len ) == 0 );

    TEST_ASSERT( mps_l1_free( &cli ) == 0 );
    TEST_ASSERT( mps_l1_free( &srv ) == 0 );

    TEST_ASSERT( mps_alloc_free( &cli_alloc ) == 0 );
    TEST_ASSERT( mps_alloc_free( &srv_alloc ) == 0 );

    layer0_free( &s2c );
    layer0_free( &c2s );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_L1 */
void mbedtls_mps_l1_want_write( int client_write_instead_reflush,
                                int server_trigger_want_read )
{
    mps_alloc cli_alloc, srv_alloc;
    mps_l1 cli, srv;

    /* This test exercises the behavior of the writing
     * side of Layer 1 if the underlying stream transport
     * cannot deliver all data.
     * Concretely:
     * 1. Client dispatches 20 bytes and attempts to flush.
     *    Only 10 bytes can be flushed, and the client gets
     *    WANT_WRITE.
     * 2. Client attempts another write, but the flush --
     *    which still can't make progress -- takes precedence,
     *    so WANT_WRITE is returned again.
     * 3a. Server reads 10 bytes, succeeds and consumes.
     * 3b. Server reads 20 bytes and fails with WANT_READ.
     * [ `server_trigger_want_read` decides between 3a and 3b ]
     * 4a. Client retries the flush and succeeds.
     * 4b. Client retries the write and succeeds.
     * [ `client_write_instead_reflush` decides between 4a and 4b ]
     * 5a (3a cont'd). Server reads 10 bytes successfully and consumes.
     * 5b (3b cont'd). Server re-tries 20 byte request and succeeds.
     */

    unsigned char data[20];
    size_t const data_len = sizeof( data );
    unsigned char *out_buf;
    unsigned char *in_buf;
    size_t out_len;

    /* Initialize Layer 0 mock objects */
    layer0_bufsize = (size_t) data_len / 2;
    TEST_ASSERT( layer0_init( &s2c ) == 0 );
    TEST_ASSERT( layer0_init( &c2s ) == 0 );

    /* Initialize allocators */
    mps_alloc_init( &cli_alloc, 100 );
    mps_alloc_init( &srv_alloc, 100 );

    /* Initialize Layer 1 */
    TEST_ASSERT( mps_l1_init( &cli, MPS_L1_MODE_STREAM, &cli_alloc,
                              layer0_write_cli, layer0_read_cli ) == 0 );
    TEST_ASSERT( mps_l1_init( &srv, MPS_L1_MODE_STREAM, &srv_alloc,
                              layer0_write_srv, layer0_read_srv ) == 0 );

    /* Generate the random content to be exchanged */
    TEST_ASSERT( rnd_std_rand( NULL, data, data_len ) == 0 );

    /* Step 1: Client prepares, dispatches and attempts to flush 20 bytes. */
    TEST_ASSERT( mps_l1_write( &cli, &out_buf, &out_len ) == 0 );

    /* The allocator is configured so that it should return
     * a buffer large enough to hold all data to be sent. */
    TEST_ASSERT( out_len >= data_len );
    memcpy( out_buf, data, data_len );

    TEST_ASSERT( mps_l1_dispatch( &cli, data_len ) == 0 );
    TEST_ASSERT( mps_l1_flush( &cli ) == MPS_ERR_WANT_WRITE );

    /* Step 2: Client attempts another write. */
    TEST_ASSERT( mps_l1_write( &cli, &out_buf, &out_len ) == MPS_ERR_WANT_WRITE );

    /* Step 3a and 3b */
    if( ! server_trigger_want_read )
    {
        /* Step 3a: Server reads 10 bytes and consumes. */
        TEST_ASSERT( mps_l1_fetch( &srv, &in_buf, data_len / 2 ) == 0 );
        TEST_ASSERT( memcmp( in_buf, data, data_len / 2 ) == 0 );
        TEST_ASSERT( mps_l1_consume( &srv ) == 0 );
    }
    else
    {
        /* Step 3b: Server reads 20 bytes and fails. */
        /* Nonetheless, the attempt should have fetched the
         * available 10 bytes from the underlying Layer 0,
         * allowing more data to be sent by the client. */
        TEST_ASSERT( mps_l1_fetch( &srv, &in_buf, data_len ) ==
                     MPS_ERR_WANT_READ );
    }

    /* Step 4a and 4b */
    if( ! client_write_instead_reflush )
    {
        /* Step 4a: Client retries flush */
        TEST_ASSERT( mps_l1_flush( &cli ) == 0 );
    }
    else
    {
        /* Step 4b: Client tries another write. */
        TEST_ASSERT( mps_l1_write( &cli, &out_buf, &out_len ) == 0 );
        /* Don't actually write anything. */
        TEST_ASSERT( mps_l1_dispatch( &cli, 0 ) == 0 );
    }

    /* Step 5a and 5b */
    if( ! server_trigger_want_read )
    {
        /* Step 5a: Server reads next 10 bytes and consumes. */
        TEST_ASSERT( mps_l1_fetch( &srv, &in_buf, data_len / 2 ) == 0 );
        TEST_ASSERT( memcmp( in_buf, data + data_len / 2, data_len / 2 ) == 0 );
        TEST_ASSERT( mps_l1_consume( &srv ) == 0 );
    }
    else
    {
        /* Step 5b: Server retries to read 20 bytes and succeeds. */
        TEST_ASSERT( mps_l1_fetch( &srv, &in_buf, data_len ) == 0 );
        TEST_ASSERT( memcmp( in_buf, data, data_len ) == 0 );
    }

    TEST_ASSERT( mps_l1_free( &cli ) == 0 );
    TEST_ASSERT( mps_l1_free( &srv ) == 0 );

    TEST_ASSERT( mps_alloc_free( &cli_alloc ) == 0 );
    TEST_ASSERT( mps_alloc_free( &srv_alloc ) == 0 );

    layer0_free( &s2c );
    layer0_free( &c2s );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_L1 */
void mbedtls_mps_l1_overly_large_request()
{
    mps_alloc alloc;
    mps_l1 l1;

    unsigned char *in_buf;

    /* Initialize Layer 0 mock objects */
    layer0_bufsize = (size_t) 10;
    TEST_ASSERT( layer0_init( &s2c ) == 0 );
    TEST_ASSERT( layer0_init( &c2s ) == 0 );

    /* Initialize allocator */
    mps_alloc_init( &alloc, 90 );

    /* Initialize Layer 1 */
    TEST_ASSERT( mps_l1_init( &l1, MPS_L1_MODE_STREAM, &alloc,
                              layer0_write_cli, layer0_read_cli ) == 0 );

    /* Try to request more data than what fits in the allocator buffer. */
    TEST_ASSERT( mps_l1_fetch( &l1, &in_buf, 90 ) ==
                 MPS_ERR_WANT_READ );
    TEST_ASSERT( mps_l1_fetch( &l1, &in_buf, 90 + 1 ) ==
                 MPS_ERR_BUFFER_TOO_SMALL );

    TEST_ASSERT( mps_l1_free( &l1 ) == 0 );
    TEST_ASSERT( mps_alloc_free( &alloc ) == 0 );
    layer0_free( &s2c );
    layer0_free( &c2s );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_L1 */
void mbedtls_mps_l1_random_communication( int allocator_buffer_sz,
                                          int layer0_buffer_sz )
{
    int ret;
    mps_alloc cli_alloc, srv_alloc;
    mps_l1 cli, srv;

    /* This test exercises a random of way for a client and server
     * to send and receive a fixed amount of data through Layer 1.
     *
     * - The send buffers xxx_send_buffer hold what each side wants to transmit,
     *   and xxx_send_pos indicates what has already been dispatched to layer 1.
     *
     * - The receive buffers xxx_recv_buffer store what has already been fetched
     *   from layer 1, with xxx_recv_pos indicating the current read position.
     *
     * NOTE: This test uses rand() for random data, which is not optimal.
     *       Instead, it would be better to get the random data from a
     *       static buffer. This both eases reproducibility and allows
     *       simple conversion to a fuzz target.
     */

    size_t len_total = 10000;
    unsigned char c2s_send_buffer[10000];
    unsigned char c2s_recv_buffer[10000];
    unsigned char s2c_send_buffer[10000];
    unsigned char s2c_recv_buffer[10000];
    size_t c2s_send_pos = 0, s2c_send_pos = 0;
    size_t c2s_recv_pos = 0, s2c_recv_pos = 0;

    /* This probably needs to be changed because we want
     * our tests to be deterministic. */
    srand( time( NULL ) );

    /* Initialize Layer 0 mock objects */
    layer0_bufsize = (size_t) layer0_buffer_sz;
    TEST_ASSERT( layer0_init( &s2c ) == 0 );
    TEST_ASSERT( layer0_init( &c2s ) == 0 );

    /* Initialize allocators */
    mps_alloc_init( &cli_alloc, allocator_buffer_sz );
    mps_alloc_init( &srv_alloc, allocator_buffer_sz );

    /* Initialize Layer 1 */
    TEST_ASSERT( mps_l1_init( &cli, MPS_L1_MODE_STREAM, &cli_alloc,
                              layer0_write_cli, layer0_read_cli ) == 0 );
    TEST_ASSERT( mps_l1_init( &srv, MPS_L1_MODE_STREAM, &srv_alloc,
                              layer0_write_srv, layer0_read_srv ) == 0 );

    /* Generate the random content to be exchanged */
    TEST_ASSERT( rnd_std_rand( NULL, c2s_send_buffer,
                               sizeof( c2s_send_buffer ) ) == 0 );
    TEST_ASSERT( rnd_std_rand( NULL, s2c_send_buffer,
                               sizeof( s2c_send_buffer ) ) == 0 );

    /* Loop as long as at least client or server haven't completed
     * receiving or sending. */
    while( c2s_send_pos < len_total || c2s_recv_pos < len_total ||
           s2c_send_pos < len_total || s2c_recv_pos < len_total )
    {
        /* Point to the respective variables for client/server,
         * depending on the random choice of actor in this round. */
        mps_l1 *actor;
        unsigned char *recv_dst_buf, *send_src_buf;
        unsigned char *send_dst_buf, *recv_src_buf;
        size_t *send_pos, *recv_pos;
        /* Randomly choose between server and client */
        if( rand() & 1 )
        {
            actor = &cli;
            send_pos = &c2s_send_pos;
            recv_pos = &c2s_recv_pos;
            recv_dst_buf = c2s_recv_buffer;
            send_src_buf = c2s_send_buffer;
        }
        else
        {
            actor = &srv;
            send_pos = &s2c_send_pos;
            recv_pos = &s2c_recv_pos;
            recv_dst_buf = s2c_recv_buffer;
            send_src_buf = s2c_send_buffer;
        }

        /* Choose between sending and receiving */
        if( rand() & 1 )
        {
            /* Sending */
            size_t send_attempt;
            size_t send_dst_len;

            /* Once we have dispatched everything, only call flush.
             * And even if we have more to dispatch, call flush randomly. */
            if( len_total == *send_pos || rand() % 4 )
            {
                ret = mps_l1_flush( actor );
                TEST_ASSERT( ret == 0 || ret == MPS_ERR_WANT_WRITE );
                continue;
            }

            /* Request write-buffer from Layer 1
             * It might be that the request is not successful because
             * data is pending to be flushed first; in this case, skip
             * the step for now. */
            ret = mps_l1_write( actor, &send_dst_buf, &send_dst_len );
            TEST_ASSERT( ret == 0 || ret == MPS_ERR_WANT_WRITE );
            if( ret != 0 )
                continue;

            /* Pick a random, nonempty percentage of the remaining data
             * to be sent and copy it into the write-buffer */
            if( send_dst_len > len_total - *send_pos )
                send_dst_len = len_total - *send_pos;
            send_attempt = ( send_dst_len * ( ( rand() % 25 ) + 1 ) ) / 100;
            if( send_attempt == 0 )
                send_attempt = 1;
            memcpy( send_dst_buf, send_src_buf + *send_pos, send_attempt );

            /* Transfer data to Layer 1 -- note that this does not
             * necessarily immediately transfer the data to Layer 0. */
            ret = mps_l1_dispatch( actor, send_attempt );
            TEST_ASSERT( ret == 0 || ret == MPS_ERR_WANT_WRITE );

            *send_pos += send_attempt;
        }
        else
        {
            /* Receiving */
            size_t recv_attempt;

            /* Skip this if we have already received everything */
            if( len_total == *recv_pos )
                continue;

            /* Pick random, nonempty share of the data still
             * remaining to be received. */
            recv_attempt = len_total - *recv_pos;
            if( recv_attempt > 10 * (unsigned) allocator_buffer_sz )
                recv_attempt = 10 * (unsigned) allocator_buffer_sz;

            recv_attempt = ( recv_attempt * ( ( rand() % 10 ) + 1 ) ) / 100;

            if( recv_attempt == 0 )
                recv_attempt = 1;

            /* Attempt to fetch the data.
             * Layer 1 never returns less than the requested amount
             * to the user; instead, if the read cannot be fulfilled
             * in its entirety, WANT_READ is returned, and one should
             * retry later. */
            ret = mps_l1_fetch( actor, &recv_src_buf, recv_attempt );
            TEST_ASSERT( ret == 0 || ret == MPS_ERR_WANT_READ ||
                         ( recv_attempt > (unsigned) allocator_buffer_sz &&
                           ret == MPS_ERR_BUFFER_TOO_SMALL ) );
            if( ret != 0 )
                continue;

            /* Randomly decide to ignore (and re-read on the next occasion)
             * the fetched contents. */
            if( rand() & 1 )
                continue;

            /* Request was successful; copy data to local buffer
             * and notify Layer 1 that it is fully consumed. */
            memcpy( recv_dst_buf + *recv_pos, recv_src_buf, recv_attempt );
            TEST_ASSERT( mps_l1_consume( actor ) == 0 );

            *recv_pos += recv_attempt;
        }
    }

    /* Ensure that both parties have observed the same communication. */
    TEST_ASSERT( memcmp( c2s_recv_buffer, s2c_send_buffer, len_total ) == 0 );
    TEST_ASSERT( memcmp( s2c_recv_buffer, c2s_send_buffer, len_total ) == 0 );

    TEST_ASSERT( mps_l1_free( &cli ) == 0 );
    TEST_ASSERT( mps_l1_free( &srv ) == 0 );

    TEST_ASSERT( mps_alloc_free( &cli_alloc ) == 0 );
    TEST_ASSERT( mps_alloc_free( &srv_alloc ) == 0 );

    layer0_free( &s2c );
    layer0_free( &c2s );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_L1 */
void mbedtls_mps_l1_random_communication_dgram( int max_dgram_size )
{
    int ret;
    mps_alloc cli_alloc, srv_alloc;
    mps_l1 cli, srv;

    /* This test exercises a random of way for a client and server
     * to send and receive a fixed amount of data through Layer 1.
     *
     * - The send buffers xxx_send_buffer hold what each side wants to transmit,
     *   and xxx_send_pos indicates what has already been dispatched to layer 1.
     *
     * - The receive buffers xxx_recv_buffer store what has already been fetched
     *   from layer 1, with xxx_recv_pos indicating the current read position.
     *
     * NOTE: This test uses rand() for random data, which is not optimal.
     *       Instead, it would be better to get the random data from a
     *       static buffer. This both eases reproducibility and allows
     *       simple conversion to a fuzz target.
     */

    size_t len_total = 10000;
    unsigned char c2s_send_buffer[10000];
    unsigned char c2s_recv_buffer[10000];
    unsigned char s2c_send_buffer[10000];
    unsigned char s2c_recv_buffer[10000];
    size_t c2s_send_pos = 0, s2c_send_pos = 0;
    size_t c2s_recv_pos = 0, s2c_recv_pos = 0;

    /* This probably needs to be changed because we want
     * our tests to be deterministic. */
    srand( time( NULL ) );

    /* Initialize Layer 0 mock objects */
    TEST_ASSERT( layer0_dgram_init( &s2c_d ) == 0 );
    TEST_ASSERT( layer0_dgram_init( &c2s_d ) == 0 );

    /* Initialize allocators */
    mps_alloc_init( &cli_alloc, max_dgram_size );
    mps_alloc_init( &srv_alloc, max_dgram_size );

    /* Initialize Layer 1 */
    TEST_ASSERT( mps_l1_init( &cli, MPS_L1_MODE_DGRAM, &cli_alloc,
                              layer0_dgram_write_cli,
                              layer0_dgram_read_cli ) == 0 );
    TEST_ASSERT( mps_l1_init( &srv, MPS_L1_MODE_DGRAM, &srv_alloc,
                              layer0_dgram_write_srv,
                              layer0_dgram_read_srv ) == 0 );

    /* Generate the random content to be exchanged */
    TEST_ASSERT( rnd_std_rand( NULL, c2s_send_buffer,
                               sizeof( c2s_send_buffer ) ) == 0 );
    TEST_ASSERT( rnd_std_rand( NULL, s2c_send_buffer,
                               sizeof( s2c_send_buffer ) ) == 0 );

    /* Loop as long as at least client or server haven't completed
     * receiving or sending. */
    while( c2s_send_pos < len_total || c2s_recv_pos < len_total ||
           s2c_send_pos < len_total || s2c_recv_pos < len_total )
    {
        /* Point to the respective variables for client/server,
         * depending on the random choice of actor in this round. */
        mps_l1 *actor;
        unsigned char *recv_dst_buf, *send_src_buf;
        unsigned char *send_dst_buf, *recv_src_buf;
        size_t *send_pos, *recv_pos;
        /* Randomly choose between server and client */
        if( rand() & 1 )
        {
            actor = &cli;
            send_pos = &c2s_send_pos;
            recv_pos = &c2s_recv_pos;
            recv_dst_buf = c2s_recv_buffer;
            send_src_buf = c2s_send_buffer;
        }
        else
        {
            actor = &srv;
            send_pos = &s2c_send_pos;
            recv_pos = &s2c_recv_pos;
            recv_dst_buf = s2c_recv_buffer;
            send_src_buf = s2c_send_buffer;
        }

        /* Choose between sending and receiving */
        if( rand() & 1 )
        {
            /* Sending */
            size_t send_attempt;
            size_t send_dst_len;

            /* Once we have dispatched everything, only call flush.
             * And even if we have more to dispatch, call flush randomly. */
            if( len_total == *send_pos || rand() % 4 )
            {
                ret = mps_l1_flush( actor );
                TEST_ASSERT( ret == 0 || ret == MPS_ERR_WANT_WRITE );
                continue;
            }

            /* Request write-buffer from Layer 1
             * It might be that the request is not successful because
             * data is pending to be flushed first; in this case, skip
             * the step for now. */
            ret = mps_l1_write( actor, &send_dst_buf, &send_dst_len );
            TEST_ASSERT( ret == 0 || ret == MPS_ERR_WANT_WRITE );
            if( ret != 0 )
                continue;

            /* Pick a random, nonempty percentage of the remaining data
             * to be sent and copy it into the write-buffer */
            if( send_dst_len > len_total - *send_pos )
                send_dst_len = len_total - *send_pos;
            send_attempt = ( send_dst_len * ( ( rand() % 25 ) + 1 ) ) / 100;
            if( send_attempt == 0 )
                send_attempt = 1;
            memcpy( send_dst_buf, send_src_buf + *send_pos, send_attempt );

            /* Transfer data to Layer 1 -- note that this does not
             * necessarily immediately transfer the data to Layer 0. */
            ret = mps_l1_dispatch( actor, send_attempt );
            TEST_ASSERT( ret == 0 || ret == MPS_ERR_WANT_WRITE );

            *send_pos += send_attempt;
        }
        else
        {
            /* Receiving */
            size_t recv_attempt;

            /* Skip this if we have already received everything */
            if( len_total == *recv_pos )
                continue;

            /* Pick random, nonempty share of the data still
             * remaining to be received. */
            recv_attempt = len_total - *recv_pos;
            if( recv_attempt > 10 * (unsigned) max_dgram_size )
                recv_attempt = 10 * (unsigned) max_dgram_size;

            recv_attempt = ( recv_attempt * ( ( rand() % 10 ) + 1 ) ) / 100;

            if( recv_attempt == 0 )
                recv_attempt = 1;

            /* Attempt to fetch the data.
             * Layer 1 never returns less than the requested amount
             * to the user; instead, if the read cannot be fulfilled
             * in its entirety, WANT_READ is returned, and one should
             * retry later. */
            ret = mps_l1_fetch( actor, &recv_src_buf, recv_attempt );
            TEST_ASSERT( ret == 0 || ret == MPS_ERR_WANT_READ ||
                         ( recv_attempt > (unsigned) max_dgram_size &&
                           ret == MPS_ERR_BUFFER_TOO_SMALL ) );
            if( ret != 0 )
                continue;

            /* Randomly decide to ignore (and re-read on the next occasion)
             * the fetched contents. */
            if( rand() & 1 )
                continue;

            /* Request was successful; copy data to local buffer
             * and notify Layer 1 that it is fully consumed. */
            memcpy( recv_dst_buf + *recv_pos, recv_src_buf, recv_attempt );
            TEST_ASSERT( mps_l1_consume( actor ) == 0 );

            *recv_pos += recv_attempt;
        }
    }

    /* Ensure that both parties have observed the same communication. */
    TEST_ASSERT( memcmp( c2s_recv_buffer, s2c_send_buffer, len_total ) == 0 );
    TEST_ASSERT( memcmp( s2c_recv_buffer, c2s_send_buffer, len_total ) == 0 );

    TEST_ASSERT( mps_l1_free( &cli ) == 0 );
    TEST_ASSERT( mps_l1_free( &srv ) == 0 );

    TEST_ASSERT( mps_alloc_free( &cli_alloc ) == 0 );
    TEST_ASSERT( mps_alloc_free( &srv_alloc ) == 0 );

    layer0_dgram_free( &s2c_d );
    layer0_dgram_free( &c2s_d );
}
/* END_CASE */
